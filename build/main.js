/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded CSS chunks
/******/ 	var installedCssChunks = {
/******/ 		"main": 0
/******/ 	}
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"main": 0
/******/ 	};
/******/
/******/
/******/
/******/ 	// script path function
/******/ 	function jsonpScriptSrc(chunkId) {
/******/ 		return __webpack_require__.p + "" + ({}[chunkId]||chunkId) + ".js"
/******/ 	}
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var promises = [];
/******/
/******/
/******/ 		// mini-css-extract-plugin CSS loading
/******/ 		var cssChunks = {"1":1};
/******/ 		if(installedCssChunks[chunkId]) promises.push(installedCssChunks[chunkId]);
/******/ 		else if(installedCssChunks[chunkId] !== 0 && cssChunks[chunkId]) {
/******/ 			promises.push(installedCssChunks[chunkId] = new Promise(function(resolve, reject) {
/******/ 				var href = "" + ({}[chunkId]||chunkId) + ".css";
/******/ 				var fullhref = __webpack_require__.p + href;
/******/ 				var existingLinkTags = document.getElementsByTagName("link");
/******/ 				for(var i = 0; i < existingLinkTags.length; i++) {
/******/ 					var tag = existingLinkTags[i];
/******/ 					var dataHref = tag.getAttribute("data-href") || tag.getAttribute("href");
/******/ 					if(tag.rel === "stylesheet" && (dataHref === href || dataHref === fullhref)) return resolve();
/******/ 				}
/******/ 				var existingStyleTags = document.getElementsByTagName("style");
/******/ 				for(var i = 0; i < existingStyleTags.length; i++) {
/******/ 					var tag = existingStyleTags[i];
/******/ 					var dataHref = tag.getAttribute("data-href");
/******/ 					if(dataHref === href || dataHref === fullhref) return resolve();
/******/ 				}
/******/ 				var linkTag = document.createElement("link");
/******/ 				linkTag.rel = "stylesheet";
/******/ 				linkTag.type = "text/css";
/******/ 				linkTag.onload = resolve;
/******/ 				linkTag.onerror = function(event) {
/******/ 					var request = event && event.target && event.target.src || fullhref;
/******/ 					var err = new Error("Loading CSS chunk " + chunkId + " failed.\n(" + request + ")");
/******/ 					err.code = "CSS_CHUNK_LOAD_FAILED";
/******/ 					err.request = request;
/******/ 					delete installedCssChunks[chunkId]
/******/ 					linkTag.parentNode.removeChild(linkTag)
/******/ 					reject(err);
/******/ 				};
/******/ 				linkTag.href = fullhref;
/******/
/******/ 				var head = document.getElementsByTagName("head")[0];
/******/ 				head.appendChild(linkTag);
/******/ 			}).then(function() {
/******/ 				installedCssChunks[chunkId] = 0;
/******/ 			}));
/******/ 		}
/******/
/******/ 		// JSONP chunk loading for javascript
/******/
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData !== 0) { // 0 means "already installed".
/******/
/******/ 			// a Promise means "currently loading".
/******/ 			if(installedChunkData) {
/******/ 				promises.push(installedChunkData[2]);
/******/ 			} else {
/******/ 				// setup Promise in chunk cache
/******/ 				var promise = new Promise(function(resolve, reject) {
/******/ 					installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 				});
/******/ 				promises.push(installedChunkData[2] = promise);
/******/
/******/ 				// start chunk loading
/******/ 				var script = document.createElement('script');
/******/ 				var onScriptComplete;
/******/
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.src = jsonpScriptSrc(chunkId);
/******/
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				onScriptComplete = function (event) {
/******/ 					// avoid mem leaks in IE.
/******/ 					script.onerror = script.onload = null;
/******/ 					clearTimeout(timeout);
/******/ 					var chunk = installedChunks[chunkId];
/******/ 					if(chunk !== 0) {
/******/ 						if(chunk) {
/******/ 							var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 							var realSrc = event && event.target && event.target.src;
/******/ 							error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 							error.name = 'ChunkLoadError';
/******/ 							error.type = errorType;
/******/ 							error.request = realSrc;
/******/ 							chunk[1](error);
/******/ 						}
/******/ 						installedChunks[chunkId] = undefined;
/******/ 					}
/******/ 				};
/******/ 				var timeout = setTimeout(function(){
/******/ 					onScriptComplete({ type: 'timeout', target: script });
/******/ 				}, 120000);
/******/ 				script.onerror = script.onload = onScriptComplete;
/******/ 				document.head.appendChild(script);
/******/ 			}
/******/ 		}
/******/ 		return Promise.all(promises);
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/build/";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../libs/lizzi/DOM/MainApp.js":
/*!************************************!*\
  !*** ../libs/lizzi/DOM/MainApp.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {ViewComponent, Loader} = __webpack_require__(/*! ./index */ \"../libs/lizzi/DOM/index.js\");\nconst {Data} = __webpack_require__(/*! ../index */ \"../libs/lizzi/index.js\");\n\nclass zzTitleView extends ViewComponent{\n    __initDOM(T){\n        this.DOM = Loader(document).find('title');\n    }\n};\n\nclass zzBodyView extends ViewComponent{\n    __initDOM(T){\n        this.DOM = Loader(document).find('body');\n    }\n};\n\nclass MainApp extends Data{\n    main(field){\n        this.app = field;\n        \n        return this;\n    }\n    \n    setTitle(title){\n        this.title = title;\n        \n        return this;\n    }\n    \n    __initBody(){\n        new zzBodyView().view('body', this.ref('app')).addEvents();\n        new zzTitleView().text('title', this.ref('title')).addEvents();\n    }\n    \n    constructor(options){\n        super();\n        \n        options || (options = {});\n        options.app || (options.app = null);\n        options.title || (options.title = 'No title');\n        \n        this.set(options);\n        \n        this.__initBody();\n    }\n};\n\nmodule.exports = {MainApp};\n\n//# sourceURL=webpack:///../libs/lizzi/DOM/MainApp.js?");

/***/ }),

/***/ "../libs/lizzi/DOM/default.js":
/*!************************************!*\
  !*** ../libs/lizzi/DOM/default.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {zzLinkFind} = __webpack_require__(/*! ./zzLink */ \"../libs/lizzi/DOM/zzLink.js\");\nconst {zzReference} = __webpack_require__(/*! ../index */ \"../libs/lizzi/index.js\");\nconst {Router} = __webpack_require__(/*! ../Router */ \"../libs/lizzi/Router/index.js\");\n\nclass zzLinkPreventSubmit extends zzLinkFind{\n    addEventToEL(el){\n        el.addEventListener('submit', function(event){\n            event.preventDefault();\n        }.bind(this), false);\n    }\n    \n    constructor(DOMFind){\n        super(DOMFind);\n    }\n}\n\nclass zzLinkInputValue extends zzLinkFind{\n    addEventToEL(el){\n        this.modelRel.onSet( function(event){\n            if (el.value !== event.value){\n                el.value = event.value;\n            }\n        }, this );\n\n        el.addEventListener('input', function(){\n            if (el.value !== this.modelRel.value){\n                let value = this.fnChange(el.value);\n                if (value !== undefined){\n                    this.modelRel.value = value;\n                }\n            }\n        }.bind(this), false);\n        \n        el.addEventListener('blur', function(){\n            if (el.value !== this.modelRel.value){\n                el.value = this.modelRel.value;\n            }\n        }.bind(this), false);\n\n        el.value = this.modelRel.value;\n    }\n    \n    clearEvents(DOMel){\n        this.modelRel.off( this );\n    }\n\n    constructor(DOMFind, modelRel, fnChange){\n        super(DOMFind);\n        \n        this.modelRel = modelRel;\n        this.fnChange = fnChange?fnChange:(v) => v;\n    }\n}\n\nclass zzLinkAutoResizeTextarea extends zzLinkFind{\n    delayedResize (text) {\n        setTimeout(() => {\n            text.style.height = 'auto';\n            text.style.height = text.scrollHeight+'px';\n        }, 0);\n    }\n    \n    addEventToEL(text){\n        text.addEventListener('change',  this.delayedResize.bind(this, text), false);\n        text.addEventListener('input',  this.delayedResize.bind(this, text), false);\n        text.addEventListener('cut',  this.delayedResize.bind(this, text), false);\n        text.addEventListener('paste',  this.delayedResize.bind(this, text), false);\n        text.addEventListener('drop',  this.delayedResize.bind(this, text), false);\n        text.addEventListener('keydown',  this.delayedResize.bind(this, text), false);\n\n        this.delayedResize(text);\n    }\n}\n\nclass zzLinkTextValue extends zzLinkFind{\n    onModelSet(DOMText, event){\n        DOMText.data = event.value;\n    };\n        \n    addEventToEL(el){\n        if (!this.append){\n            el.innerHTML = '';\n        }\n        \n        for (let i in this.modelRel){\n            let text = this.modelRel[i];\n            \n            let DOMText = document.createTextNode('');\n            \n            if (typeof text === 'string'){\n                DOMText.data = text;\n            }\n            \n            if (text instanceof zzReference){\n                text.onSet( this.onModelSet.bind(this, DOMText), this );\n                DOMText.data = text.value;\n            }\n\n            el.appendChild(DOMText);\n        }\n    }\n\n    clearEvents(DOMel){\n        for (let i in this.modelRel){\n            if (this.modelRel[i] instanceof zzReference){\n                this.modelRel[i].off( this );\n            }\n        }\n    }\n\n    constructor(DOMFind, modelRel, append){\n        super(DOMFind);\n        \n        !Array.isArray(modelRel) && (modelRel = [modelRel]);\n        \n        this.modelRel = modelRel;\n        this.append = append?true:false;\n    }\n}\n\nclass zzLinkHtmlValue extends zzLinkFind{\n    onModelChange(el){\n        let html = '';\n        for (let i in this.modelRel){\n            let text = this.modelRel[i];\n            \n            if (typeof text === 'string'){\n                html += text;\n            }\n            \n            if (text instanceof zzReference){\n                html += text.value;\n            }\n        }\n        \n        el.innerHTML = html;\n    };\n        \n    addEventToEL(el){\n        for (let i in this.modelRel){\n            if (this.modelRel[i] instanceof zzReference){\n                this.modelRel[i].onSet( this.onModelChange.bind(this, el), this );\n            }\n        }\n        \n        this.onModelChange(el);\n    }\n\n    clearEvents(){\n        for (let i in this.modelRel){\n            if (this.modelRel[i] instanceof zzReference){\n                this.modelRel[i].off( this );\n            }\n        }\n    }\n\n    constructor(DOMFind, modelRel){\n        super(DOMFind);\n        \n        !Array.isArray(modelRel) && (modelRel = [modelRel]);\n        \n        this.modelRel = modelRel;\n    }\n}\n\nclass zzLinkSwitchValue extends zzLinkFind{\n    removeClass(el, className){\n        let cels = el.className.split(' ');\n        let i = cels.indexOf(className);\n        if (i !== -1){\n            cels.splice(i, 1);\n            el.className = cels.join(' ');\n        }\n    }\n    \n    addClass(el, className){\n        let cels = el.className.split(' ');\n        cels.push(className);\n        el.className = cels.join(' ');\n    }\n    \n    addEventToEL(el){\n        let onModelSet = function(ev){\n            let s = this.sets.find(f => f.value === ev.last);\n            if (s){\n                this.removeClass(el, s.class);\n            }\n\n            s = this.sets.find(f => f.value === ev.value);\n            if (s){\n                this.addClass(el, s.class);\n            }\n        }.bind(this);\n        \n        let onClick = function(){\n            let k = this.skeys.indexOf( this.modelRel.value )+1;\n\n            if (!this.skeys[k]){k = 0;}\n\n            this.modelRel.value = this.skeys[k];\n        }.bind(this);\n        \n        this.modelRel.onSet( onModelSet, this);\n        el.addEventListener('click', onClick, false);\n\n        this.skeys.forEach(v => this.removeClass(el, this.sets[v]));\n        \n        onModelSet({last: null, value: this.modelRel.value});\n    }\n\n    clearEvents(DOMel){\n        this.modelRel.off( this );\n    }\n\n    constructor(DOMFind, modelRel, sets){\n        super(DOMFind);\n        \n        this.modelRel = modelRel;\n        this.sets = sets?sets:[\n            {value: false, class: 'off'},\n            {value: true, class: 'on'}\n        ];\n        this.skeys = this.sets.map(s => s.value);\n    }\n}\n\nclass zzLinkCheckboxValue extends zzLinkFind{\n    addEventToEL(el){\n        let onModelSet = function(ev){\n            if (el.value){\n                el.checked = (ev.value === el.value);\n            }else{\n                el.checked = ev.value?true:false;\n            }\n        }.bind(this);\n        \n        let onClick = function(e){\n            if (el.checked){\n                this.modelRel.value = el.value?el.value:true;\n            }else{\n                this.modelRel.value = el.value?'':false;\n            }\n        }.bind(this);\n        \n        this.modelRel.onSet( onModelSet, this);\n        el.addEventListener('click', onClick, false);\n\n        onModelSet({last: null, value: this.modelRel.value});\n    }\n\n    clearEvents(DOMel){\n        this.modelRel.off( this );\n    }\n\n    constructor(DOMFind, modelRel){\n        super(DOMFind);\n        \n        this.modelRel = modelRel;\n    }\n}\n\nclass zzLinkSelectValue extends zzLinkFind{\n    removeClass(el, className){\n        let cels = el.className.split(' ');\n        let i = cels.indexOf(className);\n        if (i !== -1){\n            cels.splice(i, 1);\n            el.className = cels.join(' ');\n        }\n    }\n    \n    addClass(el, className){\n        let cels = el.className.split(' ');\n        cels.push(className);\n        el.className = cels.join(' ');\n    }\n    \n    addEventToEL(el){\n        let onModelSet = function(ev){\n            let value = el.getAttribute(this.attrName) || (el.dataset[this.attrName]);\n            if (value){\n                if (ev.value === value){\n                    this.addClass(el, this.className);\n                }else{\n                    this.removeClass(el, this.className);\n                }\n            }else if (!ev.value){\n                this.addClass(el, this.className);\n            }else{\n                this.removeClass(el, this.className);\n            }\n        }.bind(this);\n        \n        let onClick = function(e){\n            let value = el.getAttribute(this.attrName) || (el.dataset[this.attrName]);\n            if (value){\n                this.modelRel.value = value;\n            }else{\n                this.modelRel.value = false;\n            }\n        }.bind(this);\n        \n        this.modelRel.onSet( onModelSet, this);\n        el.addEventListener('click', onClick, false);\n\n        onModelSet({last: null, value: this.modelRel.value});\n    }\n\n    clearEvents(DOMel){\n        this.modelRel.off( this );\n    }\n\n    constructor(DOMFind, modelRel, className, attrName){\n        super(DOMFind);\n        \n        this.modelRel = modelRel;\n        this.className = className;\n        this.attrName = attrName || 'value';\n    }\n}\n\nclass zzLinkAttributeValue extends zzLinkFind{\n    setupAttr(attr, modelArr, el){\n        var DOMAttr = document.createAttribute(attr);\n        el.setAttributeNode( DOMAttr );\n\n        let dfn = () => {\n            let value = '';\n\n            for (let model of modelArr){\n                if (model instanceof zzReference){\n                    value += model.value;\n                }else{\n                    value += model;\n                }\n            }\n            \n            DOMAttr.value = value;\n        };\n        \n        for (let model of modelArr){\n            if (model instanceof zzReference){\n                model.onSet(dfn, this);\n            }\n        }\n        \n        dfn();\n    }\n    \n    addEventToEL(el){\n        for (let name in this.attr){\n            this.setupAttr(name, this.attr[name], el);\n        }\n    }\n\n    clearEvents(){\n        for (let name in this.attr){\n            for (let model of this.attr[name]){\n                if (model instanceof zzReference){\n                    model.off( this );\n                }\n            }\n        }\n    }\n\n    constructor(DOMFind, attr, modelRel){\n        super(DOMFind);\n\n        if (typeof attr === 'string'){\n            !Array.isArray(modelRel) && (modelRel = [modelRel]);\n            this.attr = {};\n            this.attr[attr] = modelRel;\n        }else{\n            for (let name in attr){\n                !Array.isArray(attr[name]) && (attr[name] = [attr[name]]);\n                this.attr = attr;\n            }            \n        }\n    }\n}\n\nclass zzLinkStyleValue extends zzLinkAttributeValue{\n    setupAttr(style, modelArr, el){\n        let dfn = () => {\n            let value = '';\n\n            for (let model of modelArr){\n                if (model instanceof zzReference){\n                    value += model.value;\n                }else{\n                    value += model;\n                }\n            }\n            \n            el.style[style] = value;\n        };\n        \n        for (let model of modelArr){\n            if (model instanceof zzReference){\n                model.onSet(dfn, this);\n            }\n        }\n        \n        dfn();\n    }\n}\n\nclass zzLinkClassValue extends zzLinkFind{\n    addEventToEL(el){\n        let listener = function(event){\n            var cels = el.className.split(' ');\n            \n            if (event.last){\n                var remove = event.last.split(' ');\n                for (var r in remove){\n                    let i = cels.indexOf(remove[r]);\n                    if (i !== -1){\n                        cels.splice(i, 1);\n                    }            \n                }\n            }\n\n            cels.push(event.value);\n\n            el.className = cels.join(' ').replace(/\\s+/gmi,' ');\n        };\n\n        this.modelRel.onSet( listener, this);\n        \n        listener({\n            last: null,\n            value: this.modelRel.value\n        });\n    }\n\n    clearEvents(DOMel){\n        this.modelRel.off( this );\n    }\n\n    constructor(DOMFind, modelRel){\n        super(DOMFind);\n        \n        this.modelRel = modelRel;\n    }\n}\n\nclass zzLinkClassObjectValue extends zzLinkFind{\n    setupClass(className, model, el){\n        if (model instanceof zzReference){\n            let listener = function(event){\n                var cels = el.className.split(' ');\n\n                var remove = className.split(' ');\n                for (var r in remove){\n                    let i = cels.indexOf(remove[r]);\n                    if (i !== -1){\n                        cels.splice(i, 1);\n                    }            \n                }\n\n                if (event.value){\n                    cels.push(className);\n                }\n\n                el.className = cels.join(' ').replace(/\\s+/gmi,' ');\n            };\n\n            model.onSet( listener, this);\n\n            listener({\n                last: null,\n                value: model.value\n            });\n        }else if (typeof model === 'string'){\n            el.className += ' '+model;\n        }\n    }\n    \n    addEventToEL(el){\n        for (let name in this.classes){\n            this.setupClass(name, this.classes[name], el);\n        }\n    }\n\n    clearEvents(field){\n        for (let name in this.classes){\n            if (this.classes[name] instanceof zzReference){\n                this.classes[name].off( this );\n            }\n        }\n    }\n\n    constructor(DOMFind, classes){\n        super(DOMFind);\n        \n        this.classes = classes;\n    }\n}\n\nclass zzLinkClick extends zzLinkFind{\n    addEventToEL(el, DOMfield){\n        el.addEventListener('click', this.fn.bind(this.self?this.self:DOMfield, el, DOMfield));\n    }\n\n    constructor(DOMFind, fn, self){\n        super(DOMFind);\n        \n        this.fn = fn;\n        this.self = self;\n    }\n}\n\nclass zzLinkIf extends zzLinkFind{\n    addEventToEL(el){\n        let DOMEmpty = document.createTextNode('');\n        el.parentNode.insertBefore(DOMEmpty, el);\n        \n        let listener = function(event){\n            let visible = Boolean(event.value);\n            if (Boolean(event.last) !== visible){\n                if (visible){\n                    DOMEmpty.parentNode.insertBefore(el, DOMEmpty);\n                }else{\n                    el.remove();\n                }\n            }\n        };\n\n        this.modelRel.onSet( listener, this);\n        \n        listener({\n            last: true,\n            value: this.modelRel.value\n        });\n    }\n\n    clearEvents(DOMel){\n        this.modelRel.off( this );\n    }\n\n    constructor(DOMFind, modelRel){\n        super(DOMFind);\n        \n        this.modelRel = modelRel;\n    }\n}\n\nclass zzLinkRoute extends zzLinkFind{\n    getValue(v){\n        return '/'+(Array.isArray(v)?v.join('/'):v);\n    }\n    \n    addEventToEL(el){\n        var DOMAttr = document.createAttribute('href');\n        el.setAttributeNode( DOMAttr );\n\n        el.addEventListener('click', function(ev){\n            ev.preventDefault();\n            Router.go((this.modelRel instanceof zzReference)?this.modelRel.value:this.modelRel);\n        }.bind(this));\n        \n        if (this.modelRel instanceof zzReference){\n            this.modelRel.onSet( function(){\n                DOMAttr.value = this.getValue(this.modelRel.value);\n            }, this).run();\n        }else{\n            DOMAttr.value = this.getValue(this.modelRel);\n        }\n    }\n\n    clearEvents(DOMel){\n        if (this.modelRel instanceof zzReference){\n            this.modelRel.off( this );\n        }\n    }\n        \n    constructor(DOMFind, modelRel){\n        super(DOMFind);\n        \n        this.modelRel = modelRel;\n    }\n}\n\nclass zzLinkRouteHref extends zzLinkFind{\n    addEventToEL(el){\n        el.addEventListener('click', function(ev){\n            ev.preventDefault();\n            Router.go( el.getAttribute( 'href' ) );\n        }.bind(this));\n    }\n\n    clearEvents(DOMel){\n        if (this.modelRel instanceof zzReference){\n            this.modelRel.off( this );\n        }\n    }\n}\n\nmodule.exports = {\n    __zzViewAddon:{\n        /* shortcuts */\n        preventSubmit(DOMFind){\n           return this.link( new zzLinkPreventSubmit(DOMFind) );\n        },\n        input(DOMFind, modelRel, changeFn){\n           return this.link( new zzLinkInputValue(DOMFind, modelRel, changeFn) );\n        },\n        inputInteger(DOMFind, modelRel){\n           return this.input(DOMFind, modelRel, (value) => {\n                let val = parseInt(value);\n                return isNaN(val)?undefined:val;\n           });\n        },\n        inputFloat(DOMFind, modelRel){\n           return this.input(DOMFind, modelRel, (value) => {\n                let val = parseFloat(value);\n                return isNaN(val)?undefined:val;\n           });\n        },\n        checkbox(DOMFind, modelRel, sets){\n           return this.link( new zzLinkCheckboxValue(DOMFind, modelRel, sets) );\n        },\n        radio(DOMFind, modelRel, sets){\n           return this.link( new zzLinkCheckboxValue(DOMFind, modelRel, sets) );\n        },\n        select(DOMFind, modelRel, className, attrName){\n           return this.link( new zzLinkSelectValue(DOMFind, modelRel, className, attrName) );\n        },\n        autoResizeTextarea(DOMFind){\n           return this.link( new zzLinkAutoResizeTextarea(DOMFind) );\n        },\n        text(DOMFind, modelRel, append){\n           return this.link( new zzLinkTextValue(DOMFind, modelRel, append) );\n        },\n        html(DOMFind, modelRel){\n           return this.link( new zzLinkHtmlValue(DOMFind, modelRel) );\n        },\n        switch(DOMFind, modelRel, sets){\n           return this.link( new zzLinkSwitchValue(DOMFind, modelRel, sets) );\n        },\n        attr(DOMFind, attrName, modelRel){\n            return this.link( new zzLinkAttributeValue(DOMFind, attrName, modelRel) );\n        },\n        style(DOMFind, cssName, modelRel){\n            return this.link( new zzLinkStyleValue(DOMFind, cssName, modelRel) );\n        },\n        class(DOMFind, modelRel){\n            if (typeof modelRel === 'string' || modelRel instanceof zzReference){\n                return this.link( new zzLinkClassValue(DOMFind, modelRel) );\n            }else{\n                return this.link( new zzLinkClassObjectValue(DOMFind, modelRel) );\n            }\n        },\n        click(DOMFind, fn, self){\n            return this.link( new zzLinkClick(DOMFind, fn, self) );\n        },\n        if(DOMFind, modelRel){\n            return this.link( new zzLinkIf(DOMFind, modelRel) );\n        },\n        route(DOMFind, data){\n            if (data === undefined){\n                return this.link( new zzLinkRouteHref(DOMFind) );\n            }else{\n                return this.link( new zzLinkRoute(DOMFind, data) );\n            }\n        }    \n    }\n};\n\n\n//# sourceURL=webpack:///../libs/lizzi/DOM/default.js?");

/***/ }),

/***/ "../libs/lizzi/DOM/index.js":
/*!**********************************!*\
  !*** ../libs/lizzi/DOM/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n * Docs https://github.com/myrpg-fun/lizzi\n */\n\nlet {zzReference, Collection, LazyCollection} = __webpack_require__(/*! ../index */ \"../libs/lizzi/index.js\");\nlet {Event, EventListener} = __webpack_require__(/*! ../Event */ \"../libs/lizzi/Event.js\");\nlet {zzLink, zzLinkFind} = __webpack_require__(/*! ./zzLink */ \"../libs/lizzi/DOM/zzLink.js\");\n\nclass zzCollectionDOM{\n    replace(newValues){\n        let newViewComponent = [];\n        this.nodes.forEach((d, i) => d.data.__zzIndeX = i);\n        \n        if (newValues.length > 0){\n            let maxIndex = this.nodes.length;\n            let nodeBefore = null;\n            \n            let aValues;\n            \n            if (Array.isArray(newValues)){\n                aValues = newValues;\n            }else if (newValues instanceof LazyCollection || newValues instanceof Collection){\n                aValues = newValues.toArray();\n            }else{\n                aValues = [];\n            }\n            \n            for (let i = aValues.length - 1; i >= 0; i--){\n                let data = aValues[i];\n                \n                if (!data){\n                    continue;\n                }\n                \n                let node = null;\n                if ('__zzIndeX' in data){\n                    let index = data.__zzIndeX;\n                    node = this.nodes[index].node;\n                    \n                    if (index < maxIndex){\n                        maxIndex = index;\n                    }else{\n                        node.appendTo(this.DOM, nodeBefore);\n                    }\n                        \n                    delete data.__zzIndeX;\n                }else{\n                    if (data instanceof ViewComponent){\n                        node = data;\n                    }else if (data && data[this.fnname]){\n                        node = data[this.fnname].call(data);\n                    }\n                    \n                    if (node instanceof ViewComponent){\n                        node.appendTo(this.DOM, nodeBefore);\n                    }\n                }\n                \n                if (node instanceof ViewComponent){\n                    nodeBefore = node;\n//                    node.appendTo(this.DOM);\n\n                    newViewComponent.unshift({\n                        data: data,\n                        node: node\n                    });\n                }\n            };\n        }\n        \n        let removeSort = this.nodes.slice(0);\n        for (let f of removeSort){\n            if ('__zzIndeX' in f.data){\n                delete f.data.__zzIndeX;\n                f.node.removeDOM();\n            }\n        }            \n        \n        this.nodes = newViewComponent;\n    }\n    \n    remove(element, index){\n        if (this.nodes[index]){\n            if (this.nodes[index].data !== element){\n                console.error(\"Unsynced data found\");\n                return;\n            }\n            \n            this.nodes.splice(index, 1)[0].node.removeDOM();\n        }\n    }\n    \n    add(data, idx){\n        if (data[this.fnname]){\n            let node = data[this.fnname].call(data);\n            if (node){\n                node.appendTo(this.DOM, this.nodes[idx]?this.nodes[idx].node:null);\n\n                this.nodes.splice(idx, 0, {\n                    data: data,\n                    node: node\n                });\n            }\n        }\n    }\n    \n    removeDOM(){\n        this.collection.off(this);\n\n        this.nodes.forEach(function(node){\n            node.node.removeDOM();\n        });       \n        \n        //this.DOM.remove();\n        this.collection = null;\n    }\n    \n    connectDOM(collection){\n        if (!(collection instanceof Collection) && !(collection instanceof LazyCollection)){\n            console.error('Error: '+collection+' is not Collection');\n            return;\n        }\n        \n        this.collection = collection;\n        this.collection.on('add', this.add, this);\n        this.collection.on('remove', this.remove, this);\n        this.collection.on('replace-values', this.replace, this);\n        this.replace( collection.elements, this );\n    }\n    \n    constructor(Template, collection, fnname){\n        this.nodes = [];\n        this.DOM = Template;\n        this.fnname = fnname;\n        \n        this.connectDOM(collection);\n    }\n}\n\nclass zzLinkCollection extends zzLinkFind{\n    addEventToEL(el){\n        this.added.push(\n            new zzCollectionDOM(new Template(el), this.collection, this.fnname)\n        );\n    }\n\n    clearEvents(DOMel){\n        for (let i in this.added){\n            this.added[i].removeDOM();\n        }\n        \n        this.added = [];\n    }\n\n    constructor(DOMFind, collection, fnname){\n        super(DOMFind);\n        \n        if (!(collection instanceof Collection) && !(collection instanceof LazyCollection)){\n            console.error('Error: linked collection is not Collection');\n        }\n        \n        this.collection = collection;\n        this.fnname = fnname;\n        this.added = [];\n    }\n}\n\nclass zzCollectionAnimationDOM extends zzCollectionDOM{\n    replace(newValues){        \n        let newViewComponent = [];\n        this.nodes.forEach((d, i) => d.data.__zzIndeX = i);\n                \n        if (newValues.length > 0){\n            for (let data of newValues){\n                if (!data){\n                    continue;\n                }\n                \n                let node = null;\n                if ('__zzIndeX' in data){\n                    node = this.nodes[data.__zzIndeX].node;\n                    delete data.__zzIndeX;\n                }else{\n                    if (data instanceof ViewComponent){\n                        node = data;\n                    }else if (data && data[this.fnname]){\n                        node = data[this.fnname].call(data);\n                    }\n                    \n                    if (node instanceof ViewComponent){\n                        //only if new\n                        node.appendTo(this.DOM);\n                    }\n                }\n                \n                if (node instanceof ViewComponent){\n                    newViewComponent.push({\n                        data: data,\n                        node: node\n                    });\n                }\n            };\n        }\n        \n        let removeSort = this.nodes;//.slice(0);\n        for (let f of removeSort){\n            if ('__zzIndeX' in f.data){\n                delete f.data.__zzIndeX;\n                f.node.removeDOM();\n            }\n        }            \n        \n        this.nodes = newViewComponent;\n    }\n}\n\nclass zzLinkCollectionAnimation extends zzLinkCollection{\n    addEventToEL(el){\n        this.added.push(\n            new zzCollectionAnimationDOM(new Template(el), this.collection, this.fnname)\n        );\n    }\n}\n\nclass zzLinkData extends zzLinkFind{\n    async removeDOM(){\n        if (this.added.length > 0){\n            let l;\n            for (let i in this.added){\n                l = this.added[i].removeDOM();\n            }\n            await l;\n        }\n        \n        this.added = [];\n    }\n    \n    addDOM(data, el){\n        if (data && data[this.fnname]){\n            const node = data[this.fnname].call(data);\n\n            if (node instanceof ViewComponent){\n                node.appendTo(el);\n                \n                this.added.push(\n                    node\n                );\n            }\n        }\n    }\n    \n    addEventToEL(el){\n        const DataRef = this.modelRel;\n        \n        if (DataRef instanceof zzReference){\n            const data = DataRef.value;\n            this.addDOM(data, el);\n\n            let inside = false;\n            DataRef.onSet(async function(){\n                if (!inside){\n                    inside = true;\n                    await this.removeDOM();\n\n                    this.addDOM(DataRef.value, el);\n                    inside = false;\n                }\n            }, this);\n        }else{\n            this.addDOM(DataRef, el);\n        }\n    }\n\n    clearEvents(DOMel){\n        if (this.modelRel){\n            this.modelRel.off(this);\n        }\n    }\n\n    constructor(DOMFind, modelRel, fnname){\n        super(DOMFind);\n        \n        this.modelRel = modelRel;\n        this.fnname = fnname;\n        this.added = [];\n    }\n}\n\nclass zzLinkViewComponent extends zzLinkFind{\n    async removeDOM(node){\n        if (node instanceof ViewComponent){\n            await node.removeDOM();\n        }\n    }\n    \n    addDOM(node, el){\n        if (node instanceof ViewComponent){\n            node.appendTo(el);\n        }\n    }\n    \n    addEventToEL(el){\n        const node = this.node;\n        \n        if (node instanceof zzReference){\n            this.addDOM(node.value, el);\n\n            let inside = false;\n            node.onSet(async function(ev){\n                if (!inside){\n                    inside = true;\n                    if (ev.last instanceof ViewComponent){\n                        await this.removeDOM(ev.last);\n                    }\n\n                    this.addDOM(node.value, el);\n                    inside = false;\n                }\n            }, this);\n        }else if(node instanceof ViewComponent){\n            this.addDOM(node, el);\n        }\n    }\n\n    clearEvents(){\n        const node = this.node;\n        \n        if (node instanceof zzReference){\n            this.removeDOM(node.value);\n            node.off(this);\n        }else if(node instanceof ViewComponent){\n            this.removeDOM(node);\n        }\n    }\n\n    constructor(DOMFind, node){\n        super(DOMFind);\n        \n        if (!(node instanceof ViewComponent || node instanceof zzReference)){\n            console.error('Error: linked node is not ViewComponent or not zzReference');\n        }\n        \n        this.node = node;\n    }\n}\n\nclass zzInitialize extends zzLink{\n    addEvents(DOMnode){\n        if (this.initFn){\n            this.initFn(DOMnode);\n        }\n    }\n\n    async clearEvents(DOMnode){\n        if (this.destroyFn){\n            await this.destroyFn(DOMnode);\n        }\n    }\n\n    constructor(initFn, destroyFn){\n        super();\n        \n        this.initFn = initFn;\n        this.destroyFn = destroyFn;\n    }\n}\n\nclass zzLinkOn extends zzLink{\n    addEvents(view){\n        if (typeof this.self === 'string'){\n            this.self = view.find(this.self).elements[0];\n        }\n        \n        let fn = this.self.on || this.self.addEventListener || this.self.addListener;\n        \n        this.initEv = fn(this.eventName, this.listenerFn.bind(view));\n        if (this.isRun){\n            this.listenerFn.apply(view, this.isRun);\n        }\n    }\n\n    clearEvents(view){\n        if (this.initEv){\n            let fn = this.initEv.off || this.initEv.removeEventListener || this.initEv.removeListener;\n            fn(this.eventName, this.listenerFn);\n        }\n    }\n\n    constructor(self, eventName, listenerFn, isRun){\n        super();\n        \n        this.initEv = null;\n        this.listenerFn = listenerFn;\n        this.eventName = eventName;\n        this.self = self;\n        this.isRun = isRun;\n    }\n}\n\nclass Template{\n    children(){\n        let result = [];\n        for (let i in this.__zzElements){\n            if (this.__zzElements[i].content){\n                result = result.concat(Array.prototype.slice.call(this.__zzElements[i].content.childNodes));\n            }else if (this.__zzElements[i].childNodes){\n                result = result.concat(Array.prototype.slice.call(this.__zzElements[i].childNodes));\n            }\n        }\n        \n        return new Template(result);\n    }\n    \n    html(){\n        return this.__zzElements.map(el => el.innerHTML).join('');\n    }\n    \n    parse(){\n        return new Template(this.html());\n    }\n    \n    find(selector){\n        let result = [];\n        for (let i in this.__zzElements){\n            let el = this.__zzElements[i];\n            if (el instanceof Element){\n                result = result\n                    .concat(Array.prototype.slice.call(el.querySelectorAll(selector)))\n                    .concat(el.matches(selector)?[el]:[]);\n            }\n        }\n        \n        if (result.length === 0){\n            console.error('Template can not find:', selector);\n        }\n        \n        return new Template(result);\n    }\n\n    __zzConvert(template){\n        if (template instanceof Template){\n            return template.__zzElements;\n        }\n        \n        if (typeof template === 'string'){\n            if (template.indexOf('<') !== -1){\n                try {\n                    template = (new DOMParser).parseFromString(template, 'text/html');\n                    return []\n                        .concat(Array.prototype.slice.call(template.head.childNodes))\n                        .concat(Array.prototype.slice.call(template.body.childNodes));\n                }catch(err){\n                    console.error(err);\n                    return [];\n                }\n            }else{\n                template = document.querySelectorAll(template);\n            }\n        }\n        \n        if (template instanceof NodeList){\n            return Array.prototype.slice.call(template);\n        }\n        \n        if (template === undefined){\n            template = document.documentElement;\n        }\n        \n        if (template instanceof Document){\n            template = template.documentElement;\n        }\n        \n        if (template instanceof Node){\n            return [template];\n        }\n        \n        return [];\n    }\n    \n    append(DOMElement){\n        let appendTo = this.__zzElements.find(el => el instanceof Node && !(el instanceof Text));\n        if (appendTo){\n            //append to first DOM element\n            DOMElement = this.__zzConvert(DOMElement);\n\n            for (let i in DOMElement){\n                if (!(DOMElement[i] instanceof Document)){\n                    appendTo.appendChild(DOMElement[i]);\n                }\n            }\n        }\n        return this;\n    }\n    \n    appendBefore(DOMElement, BeforeElement){\n        let appendTo = this.__zzElements.find(el => el instanceof Node && !(el instanceof Text));\n        if (appendTo){\n            //append to first DOM element\n            DOMElement = this.__zzConvert(DOMElement);\n\n            for (let i in DOMElement){\n                if (!(DOMElement[i] instanceof Document)){\n                    if (BeforeElement instanceof Template){\n                        BeforeElement = BeforeElement[0];\n                    }\n                    \n                    appendTo.insertBefore(DOMElement[i], BeforeElement?BeforeElement:null);\n                }\n            }\n        }\n        return this;\n    }\n    \n    remove(){\n        for (let el of this.__zzElements){\n            if (el.parentNode){\n                el.parentNode.removeChild( el );\n            }\n        }\n        return this;\n    }\n    \n    clone(){\n        return new Template( this.__zzElements.map( el => el.cloneNode(true) ) );\n    }\n    \n    *[Symbol.iterator] () {\n        for (let el of this.__zzElements){\n            yield el;\n        }\n    }\n\n    toArray(){\n        return this.__zzElements;\n    }\n    \n    createView(selector, data){\n        return new ViewComponent( (selector === null)? this : this.find(selector), data);\n    }\n    \n    constructor(template){\n        !Array.isArray(template) && (template = [template]);\n        \n        Object.defineProperty(this, 'length', {\n            get: () => this.__zzElements.length\n        });\n\n        Object.defineProperty(this, 'elements', {\n            get: () => this.__zzElements\n        });\n        \n        this.__zzElements = [];\n        let index = 0;\n        for (let t of template){\n            let elements = this.__zzConvert( t );\n            for (let el of elements){\n                this[index++] = el;\n                this.__zzElements.push(el);\n            }\n        }\n    }\n}\n\nclass ViewComponent extends Event{\n    async removeDOM(){\n        if (this.__zzRemoveDOM){\n            this.__zzRemoveDOM = false;\n            await this.clearEvents();\n\n            this.DOM.remove();\n            this.__zzRemoveDOM = true;\n        }\n        return this;\n    }\n    \n    appendTo(DOMElement, BeforeElement){\n        if (!(DOMElement instanceof Template)){\n            DOMElement = new Template(DOMElement);\n        }\n        \n        if (DOMElement.length > 0){\n            if (BeforeElement instanceof ViewComponent){\n                BeforeElement = BeforeElement.DOM;\n            }\n            \n            this.addEvents();\n\n            DOMElement.appendBefore( this.DOM, BeforeElement );\n        }\n    }\n    \n    collection(DOMFind, collection, fnname, animation){\n        if (animation === true){\n            return this.link( new zzLinkCollectionAnimation(DOMFind, collection, fnname) );\n        }\n        \n        return this.link( new zzLinkCollection(DOMFind, collection, fnname) );\n    }\n    \n    view(DOMFind, component){\n        return this.link( new zzLinkViewComponent(DOMFind, component) );\n    }    \n    \n    data(DOMFind, data, fnname){\n        return this.link( new zzLinkData(DOMFind, data, fnname) );\n    }\n    \n    init(initFn, destroyFn){\n        return this.link( new zzInitialize(initFn, destroyFn) );\n    }\n    \n    on(self, eventName, listenerFn, isRun){\n        return this.link( new zzLinkOn(self, eventName, listenerFn, isRun) );\n    }\n    \n    /* main class*/\n    link(zzLinkEvent){\n        if (zzLinkEvent instanceof zzLink){\n            this.events.push(zzLinkEvent);\n        }\n        return this;\n    }\n    \n    addEvents(){\n        if (this.__zzClearEvents === false){\n            this.emit('add-events', this);\n            for (let eventFn of this.events){\n                eventFn.addEvents(this);\n            }\n            \n            this.__zzClearEvents = true;\n            this.emit('after-add-events', this);\n        }else if (this.__zzClearEvents === null){\n            this.once('after-clear-events', this.addEvents, this);            \n        }\n        \n        return this;\n    }\n    \n    async clearEvents(){\n        if (this.__zzClearEvents === true){\n            this.__zzClearEvents = null;\n            \n            this.emit('clear-events', this);\n            for (let eventFn of this.events){\n                await eventFn.clearEvents(this);\n            }\n            \n            this.__zzClearEvents = false;\n            this.emit('after-clear-events', this);\n        }\n        \n        return this;\n    }\n    \n    find(selector){\n        var DOMel = (selector !== null)?\n            this.DOM.find( selector ):\n            this.DOM;\n    \n        if (DOMel.length === 0){\n            console.error('Wrong selector', selector);\n        }\n        \n        return DOMel;\n    }\n\n    static addon(file){\n        if (file){\n            for (let i in file){\n                if (typeof file[i] === 'function'){\n                    ViewComponent.prototype[i] = file[i];\n                }\n            }\n        }\n    }\n    \n    __initDOM(T){\n        this.DOM = new Template(T).children().clone();\n        \n    }\n    \n    /* Create Html DOM ViewComponent */\n    constructor(T, Data){\n        super();\n        \n        this.__zzRemoveDOM = true;\n        this.__zzClearEvents = false;\n        this.Data = Data;\n        \n        this.events = [];\n\n        this.__initDOM(T);\n    }\n}\n\nViewComponent.addon( __webpack_require__(/*! ./default */ \"../libs/lizzi/DOM/default.js\").__zzViewAddon );\n\nfunction Loader(html){\n    return new Template(html);\n}\n\nmodule.exports = {ViewComponent, Loader, zzLink, zzLinkFind};\n\n//# sourceURL=webpack:///../libs/lizzi/DOM/index.js?");

/***/ }),

/***/ "../libs/lizzi/DOM/zzLink.js":
/*!***********************************!*\
  !*** ../libs/lizzi/DOM/zzLink.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("class zzLink{\n    addEvents(Field){}\n    clearEvents(Field){}\n}\n\nclass zzLinkFind extends zzLink{\n    addEvents(Field){\n        var els = Field.find(this.find).elements;\n        for (let i in els){\n            this.addEventToEL(els[i], Field);\n        }\n    }\n    \n    clearEvents(Field){}\n\n    constructor(selector){\n        super();\n        \n        this.find = selector;\n    }\n}\n\nmodule.exports = {zzLink, zzLinkFind};\n\n//# sourceURL=webpack:///../libs/lizzi/DOM/zzLink.js?");

/***/ }),

/***/ "../libs/lizzi/Event.js":
/*!******************************!*\
  !*** ../libs/lizzi/Event.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n * Docs https://github.com/myrpg-fun/lizzi\n */\n\nclass EventStack{\n    removeAll(){\n        let arr = this.events;\n        \n        for (let l in arr){\n            if (arr[l] instanceof EventListener){\n                arr[l].off();\n            }\n        }\n        \n        this.events = [];\n        \n        return this;\n    }\n    \n    add(events){\n        !Array.isArray(events) && (events = [events]);\n        \n        this.events = this.events.concat(events);\n        \n        return this;\n    }\n    \n    constructor(){\n        this.events = [];\n    }\n};\n\nclass EventAvoid{\n    constructor(){\n        let run = false;\n        \n        this.set = (fn) => {\n            return function(){\n                run = true;\n                fn.apply(this, arguments);\n                run = false;\n            };\n        };\n        \n        this.check = (fn) => {\n            return function(){\n                if (run){\n                    return;\n                }\n                \n                fn.apply(this, arguments);\n            };\n        };\n    }\n}\n\nclass EventsGroup{\n    add(listener, once, prepend){\n        let toGroup = once?this.once:this.many;\n        \n        if (listener instanceof EventListener){\n            if (prepend){\n                toGroup.unshift(listener);\n            }else{\n                toGroup.push(listener);\n            }\n            \n            listener.__zzAddGroup(this);\n        }\n    }\n    \n    remove(listener){\n        if (listener instanceof EventListener){\n            let i = this.once.indexOf(listener);\n            (i !== -1) && this.once.splice(i, 1);\n            \n            i = this.many.indexOf(listener);\n            (i !== -1) && this.many.splice(i, 1);\n        }\n    }\n    \n    removeFn(fn){\n        let i = 0;\n        do{\n            i = this.many.findIndex(l => l.fn === fn, i);\n            (i !== -1) && this.many.splice(i, 1);\n        }while(i !== -1);\n        \n        i = 0;\n        do{\n            i = this.once.findIndex(l => l.fn === fn, i);\n            (i !== -1) && this.once.splice(i, 1);\n        }while(i !== -1);\n    }\n    \n    removeBySelf(self){\n        let i = 0;\n        do{\n            i = this.many.findIndex(l => l.self === self, i);\n            (i !== -1) && this.many.splice(i, 1);\n        }while(i !== -1);\n        \n        i = 0;\n        do{\n            i = this.once.findIndex(l => l.self === self, i);\n            (i !== -1) && this.once.splice(i, 1);\n        }while(i !== -1);\n    }\n    \n    removeAll(){\n        let m = this.many;\n        let o = this.once;\n        \n        this.many = [];\n        this.once = [];\n        \n        for (let ml of m){\n            ml.off();\n        }\n        \n        for (let ol of o){\n            ol.off();\n        }\n        \n        return this;\n    }\n    \n    enable(args){\n        if (Array.isArray(args)){\n            this.enabled = args;\n        }else{\n            this.enabled = false;\n        }\n    }\n    \n    isEnabled(){\n        return this.enabled !== false;\n    }\n    \n    emit(argsArray){\n        let events = this.many.slice(0);\n        for (let i in events){\n            events[i].run(argsArray);\n        }\n\n        events = this.once.slice(0);\n        for (let i in events){\n            events[i].run(argsArray);\n        }\n        this.once = [];\n    }\n    \n    constructor(name){\n        this.name = name;\n        this.many = [];\n        this.once = [];\n        this.enabled = false;\n    }\n}\n\nclass EventListener{\n    off(){\n        for (let group of this.group){\n            group.remove(this);\n        }\n        \n        return this;\n    }\n    \n    run(argsArray){\n        if (this.isCalled){\n            return this;\n        }\n        \n        this.isCalled = true;\n        this.fn.apply(this.self, argsArray);\n        this.isCalled = false;\n        \n        return this;\n    }\n    \n    call(){\n        if (this.isCalled){\n            return this;\n        }\n        \n        this.isCalled = true;\n        this.fn.apply(this.self, arguments);\n        this.isCalled = false;\n        \n        return this;\n    }\n    \n    addToStack(stack){\n        stack.add(this);\n        \n        return this;\n    }\n\n    __zzAddGroup(group){\n        if (group instanceof EventsGroup){\n            this.group.push(group);\n        }\n        \n        return this;\n    }\n    \n    constructor(fn, self){\n        this.fn = fn;\n        this.self = self;\n        this.isCalled = false;\n        this.group = [];\n    }\n}\n\nclass Event{\n    __zzGetEvents(){\n        return this.__zzEvents;\n    }\n    \n    __zzGetEvent(name){\n        return this.__zzEvents[name];\n    }\n    \n    __zzCheckExistsEvent(name){\n        if (!this.__zzGetEvent(name)){\n            this.__zzEvents[name] = new EventsGroup(name);\n        }\n        return this.__zzEvents[name];\n    }\n    \n    __zzAddEventListener(name, fn, self, once, prepend){\n        !Array.isArray(name) && (name = [name]);\n        !self && (self = this);\n        !once && (once = false);\n        !prepend && (prepend = false);\n\n        let evListener;\n        if (fn instanceof EventListener){\n            evListener = fn;\n            self = evListener.self;\n            fn = evListener.fn;\n        }else{\n            evListener = new EventListener(fn, self);\n        }\n        \n        for (let i in name){\n            let evGroup = this.__zzCheckExistsEvent(name[i]);\n\n            if (evGroup.isEnabled()){\n                fn.apply(self, evGroup.enabled);\n                if (!once){\n                    evGroup.add(evListener, once, prepend);\n                }\n            }else{\n                evGroup.add(evListener, once, prepend);\n            }\n        }\n\n        return evListener;\n    }\n    \n    on(name, fn, self){\n        return this.__zzAddEventListener(name, fn, self, false, false);\n    }\n\n    once(name, fn, self){\n        return this.__zzAddEventListener(name, fn, self, true, false);\n    }\n\n    prependListener(name, fn, self){\n        return this.__zzAddEventListener(name, fn, self, false, true);\n    }\n\n    prependOnceListener(name, fn, self){\n        return this.__zzAddEventListener(name, fn, self, true, true);\n    }\n\n    /**\n     * remove event listener by name, function or class object\n     *\n     * @param {string} [name] - event name \n     * @param {string} [fn] - event function\n     * @param {string} [self] - event class object\n     */\n    off(name, fn, self){\n        if (name instanceof EventListener){\n            name.off();\n            \n            return;\n        }\n        \n        !Array.isArray(name) && (name = [name]);\n        !fn && (fn = self);\n\n        for (let i in name){\n            let evName = name[i];\n            if (typeof evName === 'string'){\n                let evGroup = this.__zzGetEvent(evName);\n\n                if (evGroup){\n                    if (typeof fn === 'function'){\n                        evGroup.removeFn(fn);\n                    }else{\n                        evGroup.removeBySelf(fn);\n                    }\n                }\n            }else{\n                let events = this.__zzGetEvents();\n                if (typeof evName === 'function'){\n                    for (let eventName in events){\n                        events[eventName].removeFn(evName);\n                    }\n                }else{\n                    for (let eventName in events){\n                        events[eventName].removeBySelf(evName);\n                    }\n                }\n            }\n        }\n    }\n    \n    /**\n     * Emit event\n     *\n     * @param   {string} name - key/index of the element in the list of jobs\n     */\n    emit(name){\n        let evGroup = this.__zzGetEvent(name);\n        if (!evGroup){\n            return false;\n        }\n        \n        evGroup.emit([].slice.call(arguments, 1));\n        \n        return true;\n    }\n    \n    /**\n     * Enable event, if event enabled, all new listeners will call automatically\n     *\n     * @param   {string} name - key/index of the element in the list of jobs\n     */\n    enable(name){\n        let evGroup = this.__zzCheckExistsEvent(name);\n        evGroup.enabled = [].slice.call(arguments);\n        \n        this.emit.apply(this, evGroup.enabled);\n    }\n    \n    isEnabled(name){\n        let evGroup = this.__zzCheckExistsEvent(name);\n        return evGroup && evGroup.isEnabled();\n    }\n    \n    /**\n     * Disable enabled event\n     *\n     * @param   {string} name - key/index of the element in the list of jobs\n     */\n    disable(name){\n        let evGroup = this.__zzCheckExistsEvent(name);\n        if (evGroup.isEnabled()){\n            evGroup.enabled = false;\n\n            this.emit.apply(this, ['disable:'+name].concat([].slice.call(arguments, 1)));\n        }\n    }\n    \n    constructor(){\n        this.__zzEvents = {};\n\n        //aliases\n        this.addListener = this.on;\n        this.removeListener = this.off;\n        this.callListener = this.emit;\n    }\n};\n\nfunction EventAfterAll(fn){\n    var __zzAfterEmitValues = [];\n    \n    return function(){\n        if (__zzAfterEmitValues.length === 0){\n            setTimeout(() => {\n                fn.call(this, __zzAfterEmitValues);\n\n                __zzAfterEmitValues = [];\n            }, 0);\n\n            __zzAfterEmitValues.push([].slice(arguments));\n        }\n    };\n}\n\nmodule.exports = {EventStack, EventListener, EventsGroup, EventAfterAll, Event, EventAvoid};\n\n\n//# sourceURL=webpack:///../libs/lizzi/Event.js?");

/***/ }),

/***/ "../libs/lizzi/Router/index.js":
/*!*************************************!*\
  !*** ../libs/lizzi/Router/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {Data} = __webpack_require__(/*! ../index */ \"../libs/lizzi/index.js\");\n\nclass Route{\n    static trimPath(path){\n        return path.trim().replace(/[\\/\\\\]+/g, '/').replace(/^\\/+|\\/+$/g, '');\n    }\n    \n    __match(regexp){\n        return regexp;\n    }\n    \n    __exact(regexp){\n        return '^'+regexp+'$';\n    }\n    \n    getRegexp(route){\n        let result = route.matchAll(/::|\\\\:|[:?](\\w+)|\\*\\*|\\*|[.()\\\\\\/+{}^$?]|([^:.()\\\\\\/+{}^$?*]+)/gmu);\n        \n        let regexp = '';\n        let params = [];\n        \n        for (let r of result){\n            if(r[1] !== undefined){\n                regexp += '([\\\\p{L}\\\\p{N}:+%_-]+)';\n                params.push(r[1]);\n            }else if(r[2] !== undefined){\n                regexp += r[2];\n            }else if (r[0] === '*'){\n                regexp += '[^./]+';\n            }else if (r[0] === '**'){\n                regexp += '.*';\n            }else{\n                regexp += '\\\\'+r[0];\n            }\n        }\n        \n        return { params, \n            regexp: new RegExp(this.__match(regexp), 'mu'), \n            exact: new RegExp(this.__exact(regexp), 'mu') \n        };\n    }\n    \n    async runMatch(route){\n        let exact = this.exact.test(route);\n        \n        let match = route.match(this.regexp);\n        \n//        console.log(route, this.route, this.regexp, match, exact);\n        \n        if (match !== null){\n            if (!this.match){\n                //run one time\n                this.match = true;\n                let params = {};\n                for (let k in this.params){\n                    params[this.params[k]] = match[k*1+1];\n                }\n\n                if (typeof this.listener === 'function'){\n                    await this.listener.call(this.self, params, this);\n                }\n            }\n        }else{\n            this.match = false;\n        }\n        \n        return exact;\n    }\n    \n    runWildCard(){}\n    \n    add(route, listener, self){\n        return this.Router.add(this.route+'/'+route, listener, self);\n    }\n    \n    exactMatch(route, listener, self){\n        return this.Router.exactMatch(this.route+'/'+route, listener, self);\n    }\n    \n    noMatch(listener, self){\n        return this.Router.noMatch(listener, self);\n    }\n    \n    constructor(router, route, listener, self){\n        this.Router = router;\n        this.listener = listener;\n        this.self = self;\n        this.route = Route.trimPath(route);\n        this.match = false;\n    }\n}\n\nclass RouteFromStart extends Route{\n    __match(regexp){\n        return '^'+regexp;\n    }\n    \n    constructor(router, route, listener, self){\n        super(router, route, listener, self);\n        \n        let p = this.getRegexp(route);\n\n        this.regexp = p.regexp;\n        this.exact = p.exact;\n        this.params = p.params;\n    }\n}\n\nclass RouteUntilEnd extends Route{\n    __match(regexp){\n        return regexp+'$';\n    }\n    \n    constructor(router, route, listener, self){\n        super(router, route, listener, self);\n        \n        let p = this.getRegexp(route);\n\n        this.regexp = p.regexp;\n        this.exact = p.exact;\n        this.params = p.params;\n    }\n}\n\nclass RouteExactMatch extends Route{\n    __match(regexp){\n        return '^'+regexp+'$';\n    }\n    \n    constructor(router, route, listener, self){\n        super(router, route, listener, self);\n        \n        let p = this.getRegexp(route);\n\n        this.regexp = p.regexp;\n        this.exact = p.exact;\n        this.params = p.params;\n    }\n}\n\nclass RouteNoMatch extends Route{\n    async runMatch(route){\n        return false;\n    }\n    \n    runWildCard(){\n        this.listener.call(this.self, this);\n    }\n    \n    constructor(router, listener, self){\n        super(router, '', listener, self);\n    }\n}\n\nclass Router extends Data{\n    __zzAddRoute(newRoute){\n        this.routes.push(newRoute);\n\n        if (this.routeQueue.length === 0){\n            //start from last one\n            this.__zzOnRoute(this.routes.length - 1);\n        }\n        \n        return newRoute;\n    }\n\n    exactMatch(route, fn, self){\n        return this.__zzAddRoute(\n            new RouteExactMatch(this, this.toUrl(route), fn, self)\n        );\n    }\n\n    add(route, fn, self){\n        if (typeof route === 'function'){\n            return this.__zzAddRoute(\n                new RouteNoMatch(this, route, fn)\n            );\n        }\n        \n        return this.__zzAddRoute(\n            new RouteFromStart(this, this.toUrl(route), fn, self)\n        );\n    }\n\n    until(route, fn, self){\n        return this.__zzAddRoute(\n            new RouteUntilEnd(this, this.toUrl(route), fn, self)\n        );\n    }\n\n    noMatch(fn, self){\n        return this.__zzAddRoute(\n            new RouteNoMatch(this, fn, self)\n        );\n    }\n\n    onChange(fn, self){\n        return this.on('change', fn, self);\n    }\n\n    async __zzRun(route, index){\n        for (let i = index; i < this.routes.length; i++){\n            this.isExact |= await this.routes[i].runMatch(route);\n        }\n        \n        if (!this.isExact){\n            //no exact path, run wildcard ways\n            for (let i = index; i < this.routes.length; i++){\n                await this.routes[i].runWildCard();\n            }\n        }\n    }\n\n    async __zzOnRoute(index){\n        index || (index = 0);\n        \n        let url = this.toUrl( decodeURI( window.location.pathname ) );\n        let idx = this.routeQueue.indexOf(url);\n        if (idx === -1){\n            this.routeQueue.push( url );\n        \n            if (this.routeQueue.length === 1){\n                do{\n                    this.isExact = false;\n                    \n                    this.path = '/'+this.routeQueue[0];\n                    \n                    await this.__zzRun( this.routeQueue[0], index );\n\n                    this.emit('change', this.routeQueue[0]);\n                    //always remove after run\n                    this.routeQueue.shift();\n                }while(this.routeQueue.length > 0);\n            }\n        }\n    }\n\n    toUrl(route){\n        if (Array.isArray(route)){\n            route = route.map(function(route){\n                if (route instanceof Route){\n                    route = route.route;\n                }\n                \n                if (typeof route === 'string'){\n                    return route;\n                }\n\n                return '';\n            }).join('/');\n        }\n        \n        if (typeof route === 'string'){\n            return Route.trimPath( route );\n        }\n        \n        return '';\n    }\n\n    go(url){\n        this.state = {url: url};\n        window.history.pushState(this.state, '', '/'+this.toUrl(url));\n        this.__zzOnRoute();\n    }\n\n    setState(object){\n        for (let name in object){\n            this.state[name] = object[name];\n        }\n        \n        window.history.replaceState(this.state, '', window.location.href);\n    }\n\n    constructor(){\n        super({\n            path: null\n        });\n        \n        this.routes = [];\n        this.routeQueue = [];\n        this.isExact = false;\n        \n        window.addEventListener('popstate', (event) => {\n            this.state = event.state;\n            this.__zzOnRoute();\n        });\n        this.path = '/'+this.toUrl(window.location.pathname);\n        \n        this.state = {};\n        this.setState({url: window.location.pathname});\n    }\n};\n\nmodule.exports = {Router: new Router};\n\n//# sourceURL=webpack:///../libs/lizzi/Router/index.js?");

/***/ }),

/***/ "../libs/lizzi/index.js":
/*!******************************!*\
  !*** ../libs/lizzi/index.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\r\n * Docs https://github.com/myrpg-fun/lizzi\r\n */\r\n\r\nlet {Event} = __webpack_require__(/*! ./Event */ \"../libs/lizzi/Event.js\");\r\n\r\nclass zzReference{\r\n    onSet(fn, self){}    \r\n    off(fn, self){}\r\n}\r\n\r\nclass zzDataRef extends zzReference{\r\n    onSet(fn, self){\r\n        return this.model.on('set:'+this.name, fn, self);\r\n    }\r\n    \r\n    off(fn, self){\r\n        this.model.off('set:'+this.name, fn, self);\r\n    }\r\n\r\n    constructor(model, name){\r\n        super();\r\n        \r\n        this.model = model;\r\n        this.name = name;\r\n        this.events = [];\r\n        \r\n        Object.defineProperty(this, 'value', {\r\n            get: () => this.model[this.name],\r\n            set: (value) => this.model[this.name] = value\r\n        });\r\n    }\r\n}\r\n\r\nclass zzFunctionRef extends zzReference{\r\n    onSet(fn, self){\r\n        for (let ref of this.refs){\r\n            ref.onSet(this.bfn, self);\r\n        }\r\n    }\r\n    \r\n    off(fn, self){\r\n        for (let ref of this.refs){\r\n            ref.off(this.bfn, self);\r\n        }\r\n    }\r\n\r\n    constructor(fn, refs){\r\n        super();\r\n        \r\n        this.fn = fn.bind(this);\r\n        this.refs = refs;\r\n    }\r\n}\r\n\r\nfunction FuncRef(fn, refs){\r\n    return new zzFunctionRef(fn, refs);\r\n}\r\n\r\nclass Data extends Event{\r\n    __zzEmitAfterSet(name, value){\r\n        if (this.__zzAfterEmitValues === null){\r\n            setTimeout(() => {\r\n                this.emit('set-values', {\r\n                    values: this.__zzAfterEmitValues, target: this\r\n                });\r\n                \r\n                this.__zzAfterEmitValues = null;\r\n            }, 0);\r\n            \r\n            this.__zzAfterEmitValues = {};\r\n        }\r\n        \r\n        this.__zzAfterEmitValues[name] = value;\r\n    }\r\n    \r\n    __zzSet(name, value){\r\n        var last = this.__zzValues[name];\r\n        if (last !== value){\r\n            this.__zzValues[name] = value;\r\n            this.emit('set', {\r\n                name: name, value: value, last: last, target: this\r\n            });\r\n            this.emit('set:'+name, {\r\n                name: name, value: value, last: last, target: this\r\n            });\r\n//            this.__zzEmitAfterSet(name, value);\r\n        }\r\n    }\r\n    \r\n    ref(name){\r\n        return new zzDataRef(this, name);\r\n    }\r\n    \r\n    set(values){\r\n        if (values instanceof Data){\r\n            values = values.values();\r\n        }\r\n        \r\n        let last = {};\r\n        //set all values\r\n        for (let name in values){\r\n            if (!(name in this.__zzValues) && name !== '__zzValues'){\r\n                Object.defineProperty(this, name, {\r\n                    get: () => this.__zzValues[name],\r\n                    set: this.__zzSet.bind(this, name)\r\n                });\r\n            }\r\n\r\n            last[name] = this.__zzValues[name];\r\n            this.__zzValues[name] = values[name];\r\n        }\r\n        \r\n        //then emit\r\n        for (let name in values){\r\n            let value = this.__zzValues[name];\r\n            if (last[name] !== value){\r\n                this.emit('set', {\r\n                    name: name, value: value, last: last[name], target: this\r\n                });\r\n                this.emit('set:'+name, {\r\n                    name: name, value: value, last: last[name], target: this\r\n                });\r\n//                this.__zzEmitAfterSet(name, value);\r\n            }\r\n        }\r\n        \r\n        return this;\r\n    }\r\n    \r\n    values(){\r\n        return Object.assign({}, this.__zzValues);\r\n    }\r\n    \r\n    get(name){\r\n        return this.__zzValues[name];\r\n    }\r\n    \r\n    unset(name){\r\n        Object.defineProperty(this, name, {set:undefined, get:undefined});\r\n        \r\n        this.emit('remove-value', {\r\n            name: name, value: this.__zzValues[name], target: this\r\n        });\r\n        \r\n        delete this.__zzValues[name];\r\n    }\r\n    \r\n    constructor(data){\r\n        super();\r\n        \r\n        !data && (data = {});\r\n        \r\n        this.__zzValues = {};\r\n        this.__zzAfterEmitValues = null;\r\n        \r\n        this.set(data);\r\n    }\r\n}\r\n\r\nclass Collection extends Event{\r\n    add(data, idx){\r\n        idx === undefined && (idx = this.__zzArray.length);\r\n        !Array.isArray(data) && (data = [data]);\r\n        \r\n        return this.splice(idx, 0, ...data);\r\n    }\r\n    \r\n    addBefore(element, data){\r\n        let idx = this.indexOf(element);\r\n        if (idx === -1){\r\n            return this;\r\n        }\r\n        \r\n        return this.add(data, idx);\r\n    }\r\n    \r\n    addAfter(element, data){\r\n        let idx = this.indexOf(element);\r\n        if (idx === -1){\r\n            return this;\r\n        }\r\n        \r\n        return this.add(data, idx+1);\r\n    }\r\n    \r\n    removeAll(){\r\n        let all = this.__zzArray;\r\n        \r\n        this.__zzArray = [];\r\n        \r\n        all.forEach(function(val, idx){\r\n            this.emit('remove', val, 0, this);\r\n        }, this);\r\n        \r\n        this.emit('remove-values', all, this);\r\n        this.emit('change-values', all, this);\r\n        \r\n        return this;\r\n    }\r\n    \r\n    splice(index, count){\r\n        let newData = [].slice.call(arguments, 2);\r\n        let removeData = this.__zzArray.splice(index, count, ...newData);\r\n        \r\n        if (count > 0){\r\n            for (let i in removeData){\r\n                this.emit('remove', removeData[i], Number(index)+Number(i), this);\r\n            }\r\n        \r\n            this.emit('remove-values', removeData, this);\r\n        }\r\n\r\n        if (newData.length > 0){\r\n            newData.forEach((val, i) => {\r\n                this.emit('add', val, i+index, this);\r\n            });\r\n\r\n            this.emit('add-values', newData, index, this);\r\n        }\r\n        \r\n        this.emit('change-values', this.__zzArray, this);\r\n    }\r\n    \r\n    remove(data){\r\n        !Array.isArray(data) && (data = [data]);\r\n        \r\n        data.forEach(function(val){\r\n            let i = this.indexOf(val);\r\n            if (i !== -1){\r\n                this.splice(i, 1);\r\n            }\r\n        }.bind(this));\r\n        \r\n        this.emit('remove-values', data, this);\r\n        this.emit('change-values', this.__zzArray, this);\r\n        \r\n        return this;\r\n    }\r\n    \r\n    getByIndex(index){\r\n        return this.__zzArray[index];\r\n    }\r\n    \r\n    findIndex(func){\r\n        return this.__zzArray.findIndex(func);\r\n    }\r\n    \r\n    find(func){\r\n        return this.__zzArray.find(func);\r\n    }\r\n    \r\n    filter(func){\r\n        return this.__zzArray.filter(func);\r\n    }\r\n    \r\n    indexOf(val){\r\n        return this.__zzArray.indexOf(val);\r\n    }\r\n    \r\n    has(val){\r\n        return this.__zzArray.indexOf(val) !== -1;\r\n    }\r\n    \r\n    replace(data){\r\n        !Array.isArray(data) && (data = [data]);\r\n        \r\n        let last = this.__zzArray;\r\n        this.__zzArray = data;\r\n        \r\n        this.emit('replace-values', data, last, this);\r\n        this.emit('change-values', data, this);\r\n        \r\n        return this;\r\n    }\r\n    \r\n    refresh(){\r\n        this.emit('change-values', this.__zzArray, this);\r\n    }\r\n    \r\n    async forEach(fn, self){\r\n        for (let i in this.__zzArray){\r\n            let result = fn.call(self, this.__zzArray[i], i, this.__zzArray);\r\n            if (result instanceof Promise){\r\n                await result;\r\n            }\r\n        }\r\n    }\r\n    \r\n    *[Symbol.iterator]() {\r\n        for (let el of this.__zzArray){\r\n            yield el;\r\n        }\r\n    }\r\n\r\n    toArray(){\r\n        return this.__zzArray;\r\n    }\r\n    \r\n    constructor(array){\r\n        super();\r\n        \r\n        this.__zzArray = [];\r\n  \r\n        Object.defineProperty(this, 'length', {\r\n            get: () => this.__zzArray.length\r\n        });\r\n        \r\n        Object.defineProperty(this, 'elements', {\r\n            get: () => this.__zzArray.slice()\r\n        });\r\n        \r\n        if (array){\r\n            this.add(array);\r\n        }\r\n    }\r\n}\r\n\r\nclass LazyCollection extends Event{\r\n    /*\r\n     * filter/sort class\r\n     * \r\n     * @param {Array} elements - array of original elements\r\n     * @returns {Array} - filtered / sorted array for new collection\r\n     */\r\n    filter(elements){\r\n        return elements;\r\n    }\r\n    \r\n    setFilter(fn){\r\n        if (typeof fn === 'function'){\r\n            this.__zzFilterFn = fn;\r\n            this.refresh();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    refresh(){\r\n        this.__zzNeedUpdate = true;\r\n        this.emit('replace-values', this, this.__zzArray.slice(), this);\r\n        this.emit('change-values', this, this);\r\n    }\r\n    \r\n    /*\r\n     * add to filter outer collection to set filtered array\r\n     * \r\n     * @param {zzFCollection} collection - outer collection\r\n     */\r\n    to(collection){\r\n        this.on('change-values', () => collection.replace(this.elements), collection);\r\n        \r\n        collection.replace(this.elements);\r\n        \r\n        return this;\r\n    }\r\n    \r\n    toArray(){\r\n        if (this.__zzNeedUpdate){\r\n            this.__zzArray = this.__zzFilterFn(this.collection.elements);\r\n            this.__zzNeedUpdate = false;\r\n        };\r\n        \r\n        return this.__zzArray;\r\n    }\r\n    \r\n    async forEach(fn, self){\r\n        for (let i in this.toArray()){\r\n            let result = fn.call(self, this.__zzArray[i], i, this.__zzArray);\r\n            if (result instanceof Promise){\r\n                await result;\r\n            }\r\n        }\r\n    }\r\n    \r\n    *[Symbol.iterator]() {\r\n        for (let el of this.toArray()){\r\n            yield el;\r\n        }\r\n    }\r\n    \r\n    constructor(collection){\r\n        super();\r\n        \r\n        this.collection = collection;\r\n        this.collection.on('change-values', this.refresh, this);\r\n        \r\n        this.__zzFilterFn = this.filter;\r\n        this.__zzArray = [];\r\n        this.__zzNeedUpdate = true;\r\n        \r\n        Object.defineProperty(this, 'length', {\r\n            get: () => this.toArray().length\r\n        });\r\n        \r\n        Object.defineProperty(this, 'elements', {\r\n            get: () => this.toArray().slice()\r\n        });\r\n    }\r\n}\r\n\r\nmodule.exports = {zzReference, Data, Collection, LazyCollection, FuncRef};\n\n//# sourceURL=webpack:///../libs/lizzi/index.js?");

/***/ }),

/***/ "./app.js":
/*!****************!*\
  !*** ./app.js ***!
  \****************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _reboot_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/reboot.css */ \"./reboot.css\");\n/* harmony import */ var _reboot_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_reboot_css__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lizzi_DOM_MainApp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lizzi/DOM/MainApp */ \"../libs/lizzi/DOM/MainApp.js\");\n/* harmony import */ var lizzi_DOM_MainApp__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lizzi_DOM_MainApp__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lizzi_Router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lizzi/Router */ \"../libs/lizzi/Router/index.js\");\n/* harmony import */ var lizzi_Router__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lizzi_Router__WEBPACK_IMPORTED_MODULE_2__);\n\r\n\r\n\r\n\r\nclass MyApp extends lizzi_DOM_MainApp__WEBPACK_IMPORTED_MODULE_1__[\"MainApp\"]{\r\n    constructor(){\r\n        super({\r\n            title: 'Topia.io - loading'\r\n        });\r\n        \r\n        lizzi_Router__WEBPACK_IMPORTED_MODULE_2__[\"Router\"].exactMatch([], () => \r\n            Promise.all(/*! import() */[__webpack_require__.e(0), __webpack_require__.e(1)]).then(__webpack_require__.bind(null, /*! ./topia/app */ \"./topia/app.js\")).then(\r\n                app => {\r\n                    this.title = 'Topia.io';\r\n                    this.app = app.default.createView();\r\n                }\r\n            )\r\n        );\r\n\r\n        //404 error\r\n        lizzi_Router__WEBPACK_IMPORTED_MODULE_2__[\"Router\"].noMatch(() => \r\n            __webpack_require__.e(/*! import() */ 2).then(__webpack_require__.bind(null, /*! ./404/index */ \"./404/index.js\")).then(\r\n                app => {\r\n                    this.title = 'Topia.io - Page not found';\r\n                    this.app = app.default.createView();\r\n                }\r\n            )\r\n        );\r\n    }\r\n};\r\n\r\nconst app = new MyApp;\r\n\n\n//# sourceURL=webpack:///./app.js?");

/***/ }),

/***/ "./reboot.css":
/*!********************!*\
  !*** ./reboot.css ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n    if(false) { var cssReload; }\n  \n\n//# sourceURL=webpack:///./reboot.css?");

/***/ })

/******/ });