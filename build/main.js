/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded CSS chunks
/******/ 	var installedCssChunks = {
/******/ 		"main": 0
/******/ 	}
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"main": 0
/******/ 	};
/******/
/******/
/******/
/******/ 	// script path function
/******/ 	function jsonpScriptSrc(chunkId) {
/******/ 		return __webpack_require__.p + "" + ({}[chunkId]||chunkId) + ".js"
/******/ 	}
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var promises = [];
/******/
/******/
/******/ 		// mini-css-extract-plugin CSS loading
/******/ 		var cssChunks = {"1":1};
/******/ 		if(installedCssChunks[chunkId]) promises.push(installedCssChunks[chunkId]);
/******/ 		else if(installedCssChunks[chunkId] !== 0 && cssChunks[chunkId]) {
/******/ 			promises.push(installedCssChunks[chunkId] = new Promise(function(resolve, reject) {
/******/ 				var href = "" + ({}[chunkId]||chunkId) + ".css";
/******/ 				var fullhref = __webpack_require__.p + href;
/******/ 				var existingLinkTags = document.getElementsByTagName("link");
/******/ 				for(var i = 0; i < existingLinkTags.length; i++) {
/******/ 					var tag = existingLinkTags[i];
/******/ 					var dataHref = tag.getAttribute("data-href") || tag.getAttribute("href");
/******/ 					if(tag.rel === "stylesheet" && (dataHref === href || dataHref === fullhref)) return resolve();
/******/ 				}
/******/ 				var existingStyleTags = document.getElementsByTagName("style");
/******/ 				for(var i = 0; i < existingStyleTags.length; i++) {
/******/ 					var tag = existingStyleTags[i];
/******/ 					var dataHref = tag.getAttribute("data-href");
/******/ 					if(dataHref === href || dataHref === fullhref) return resolve();
/******/ 				}
/******/ 				var linkTag = document.createElement("link");
/******/ 				linkTag.rel = "stylesheet";
/******/ 				linkTag.type = "text/css";
/******/ 				linkTag.onload = resolve;
/******/ 				linkTag.onerror = function(event) {
/******/ 					var request = event && event.target && event.target.src || fullhref;
/******/ 					var err = new Error("Loading CSS chunk " + chunkId + " failed.\n(" + request + ")");
/******/ 					err.code = "CSS_CHUNK_LOAD_FAILED";
/******/ 					err.request = request;
/******/ 					delete installedCssChunks[chunkId]
/******/ 					linkTag.parentNode.removeChild(linkTag)
/******/ 					reject(err);
/******/ 				};
/******/ 				linkTag.href = fullhref;
/******/
/******/ 				var head = document.getElementsByTagName("head")[0];
/******/ 				head.appendChild(linkTag);
/******/ 			}).then(function() {
/******/ 				installedCssChunks[chunkId] = 0;
/******/ 			}));
/******/ 		}
/******/
/******/ 		// JSONP chunk loading for javascript
/******/
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData !== 0) { // 0 means "already installed".
/******/
/******/ 			// a Promise means "currently loading".
/******/ 			if(installedChunkData) {
/******/ 				promises.push(installedChunkData[2]);
/******/ 			} else {
/******/ 				// setup Promise in chunk cache
/******/ 				var promise = new Promise(function(resolve, reject) {
/******/ 					installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 				});
/******/ 				promises.push(installedChunkData[2] = promise);
/******/
/******/ 				// start chunk loading
/******/ 				var script = document.createElement('script');
/******/ 				var onScriptComplete;
/******/
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.src = jsonpScriptSrc(chunkId);
/******/
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				onScriptComplete = function (event) {
/******/ 					// avoid mem leaks in IE.
/******/ 					script.onerror = script.onload = null;
/******/ 					clearTimeout(timeout);
/******/ 					var chunk = installedChunks[chunkId];
/******/ 					if(chunk !== 0) {
/******/ 						if(chunk) {
/******/ 							var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 							var realSrc = event && event.target && event.target.src;
/******/ 							error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 							error.name = 'ChunkLoadError';
/******/ 							error.type = errorType;
/******/ 							error.request = realSrc;
/******/ 							chunk[1](error);
/******/ 						}
/******/ 						installedChunks[chunkId] = undefined;
/******/ 					}
/******/ 				};
/******/ 				var timeout = setTimeout(function(){
/******/ 					onScriptComplete({ type: 'timeout', target: script });
/******/ 				}, 120000);
/******/ 				script.onerror = script.onload = onScriptComplete;
/******/ 				document.head.appendChild(script);
/******/ 			}
/******/ 		}
/******/ 		return Promise.all(promises);
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/topia/build/";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../libs/lizzi/DOM/MainApp.js":
/*!************************************!*\
  !*** ../libs/lizzi/DOM/MainApp.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {ViewComponent, Loader} = __webpack_require__(/*! ./index */ \"../libs/lizzi/DOM/index.js\");\r\nconst {Data} = __webpack_require__(/*! ../index */ \"../libs/lizzi/index.js\");\r\n\r\nclass zzTitleView extends ViewComponent{\r\n    __initDOM(T){\r\n        this.DOM = Loader(document).find('title');\r\n    }\r\n};\r\n\r\nclass zzBodyView extends ViewComponent{\r\n    __initDOM(T){\r\n        this.DOM = Loader(document).find('body');\r\n    }\r\n};\r\n\r\nclass MainApp extends Data{\r\n    main(field){\r\n        this.app = field;\r\n        \r\n        return this;\r\n    }\r\n    \r\n    setTitle(title){\r\n        this.title = title;\r\n        \r\n        return this;\r\n    }\r\n    \r\n    __initBody(){\r\n        new zzBodyView().view('body', this.ref('app')).addEvents();\r\n        new zzTitleView().text('title', this.ref('title')).addEvents();\r\n    }\r\n    \r\n    constructor(options){\r\n        super();\r\n        \r\n        options || (options = {});\r\n        options.app || (options.app = null);\r\n        options.title || (options.title = 'No title');\r\n        \r\n        this.set(options);\r\n        \r\n        this.__initBody();\r\n    }\r\n};\r\n\r\nmodule.exports = {MainApp};\n\n//# sourceURL=webpack:///../libs/lizzi/DOM/MainApp.js?");

/***/ }),

/***/ "../libs/lizzi/DOM/default.js":
/*!************************************!*\
  !*** ../libs/lizzi/DOM/default.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {zzLinkFind} = __webpack_require__(/*! ./zzLink */ \"../libs/lizzi/DOM/zzLink.js\");\r\nconst {zzReference} = __webpack_require__(/*! ../index */ \"../libs/lizzi/index.js\");\r\nconst {Router} = __webpack_require__(/*! ../Router */ \"../libs/lizzi/Router/index.js\");\r\n\r\nclass zzLinkPreventSubmit extends zzLinkFind{\r\n    addEventToEL(el){\r\n        el.addEventListener('submit', function(event){\r\n            event.preventDefault();\r\n        }.bind(this), false);\r\n    }\r\n    \r\n    constructor(DOMFind){\r\n        super(DOMFind);\r\n    }\r\n}\r\n\r\nclass zzLinkInputValue extends zzLinkFind{\r\n    addEventToEL(el){\r\n        this.modelRel.onSet( function(event){\r\n            if (el.value !== event.value){\r\n                el.value = event.value;\r\n            }\r\n        }, this );\r\n\r\n        el.addEventListener('input', function(){\r\n            if (el.value !== this.modelRel.value){\r\n                let value = this.fnChange(el.value);\r\n                if (value !== undefined){\r\n                    this.modelRel.value = value;\r\n                }\r\n            }\r\n        }.bind(this), false);\r\n        \r\n        el.addEventListener('blur', function(){\r\n            if (el.value !== this.modelRel.value){\r\n                el.value = this.modelRel.value;\r\n            }\r\n        }.bind(this), false);\r\n\r\n        el.value = this.modelRel.value;\r\n    }\r\n    \r\n    clearEvents(DOMel){\r\n        this.modelRel.off( this );\r\n    }\r\n\r\n    constructor(DOMFind, modelRel, fnChange){\r\n        super(DOMFind);\r\n        \r\n        this.modelRel = modelRel;\r\n        this.fnChange = fnChange?fnChange:(v) => v;\r\n    }\r\n}\r\n\r\nclass zzLinkAutoResizeTextarea extends zzLinkFind{\r\n    delayedResize (text) {\r\n        setTimeout(() => {\r\n            text.style.height = 'auto';\r\n            text.style.height = text.scrollHeight+'px';\r\n        }, 0);\r\n    }\r\n    \r\n    addEventToEL(text){\r\n        text.addEventListener('change',  this.delayedResize.bind(this, text), false);\r\n        text.addEventListener('input',  this.delayedResize.bind(this, text), false);\r\n        text.addEventListener('cut',  this.delayedResize.bind(this, text), false);\r\n        text.addEventListener('paste',  this.delayedResize.bind(this, text), false);\r\n        text.addEventListener('drop',  this.delayedResize.bind(this, text), false);\r\n        text.addEventListener('keydown',  this.delayedResize.bind(this, text), false);\r\n\r\n        this.delayedResize(text);\r\n    }\r\n}\r\n\r\nclass zzLinkTextValue extends zzLinkFind{\r\n    onModelSet(DOMText, event){\r\n        DOMText.data = event.value;\r\n    };\r\n        \r\n    addEventToEL(el){\r\n        if (!this.append){\r\n            el.innerHTML = '';\r\n        }\r\n        \r\n        for (let i in this.modelRel){\r\n            let text = this.modelRel[i];\r\n            \r\n            let DOMText = document.createTextNode('');\r\n            \r\n            if (typeof text === 'string'){\r\n                DOMText.data = text;\r\n            }\r\n            \r\n            if (text instanceof zzReference){\r\n                text.onSet( this.onModelSet.bind(this, DOMText), this );\r\n                DOMText.data = text.value;\r\n            }\r\n\r\n            el.appendChild(DOMText);\r\n        }\r\n    }\r\n\r\n    clearEvents(DOMel){\r\n        for (let i in this.modelRel){\r\n            if (this.modelRel[i] instanceof zzReference){\r\n                this.modelRel[i].off( this );\r\n            }\r\n        }\r\n    }\r\n\r\n    constructor(DOMFind, modelRel, append){\r\n        super(DOMFind);\r\n        \r\n        !Array.isArray(modelRel) && (modelRel = [modelRel]);\r\n        \r\n        this.modelRel = modelRel;\r\n        this.append = append?true:false;\r\n    }\r\n}\r\n\r\nclass zzLinkHtmlValue extends zzLinkFind{\r\n    onModelChange(el){\r\n        let html = '';\r\n        for (let i in this.modelRel){\r\n            let text = this.modelRel[i];\r\n            \r\n            if (typeof text === 'string'){\r\n                html += text;\r\n            }\r\n            \r\n            if (text instanceof zzReference){\r\n                html += text.value;\r\n            }\r\n        }\r\n        \r\n        el.innerHTML = html;\r\n    };\r\n        \r\n    addEventToEL(el){\r\n        for (let i in this.modelRel){\r\n            if (this.modelRel[i] instanceof zzReference){\r\n                this.modelRel[i].onSet( this.onModelChange.bind(this, el), this );\r\n            }\r\n        }\r\n        \r\n        this.onModelChange(el);\r\n    }\r\n\r\n    clearEvents(){\r\n        for (let i in this.modelRel){\r\n            if (this.modelRel[i] instanceof zzReference){\r\n                this.modelRel[i].off( this );\r\n            }\r\n        }\r\n    }\r\n\r\n    constructor(DOMFind, modelRel){\r\n        super(DOMFind);\r\n        \r\n        !Array.isArray(modelRel) && (modelRel = [modelRel]);\r\n        \r\n        this.modelRel = modelRel;\r\n    }\r\n}\r\n\r\nclass zzLinkSwitchValue extends zzLinkFind{\r\n    removeClass(el, className){\r\n        let cels = el.className.split(' ');\r\n        let i = cels.indexOf(className);\r\n        if (i !== -1){\r\n            cels.splice(i, 1);\r\n            el.className = cels.join(' ');\r\n        }\r\n    }\r\n    \r\n    addClass(el, className){\r\n        let cels = el.className.split(' ');\r\n        cels.push(className);\r\n        el.className = cels.join(' ');\r\n    }\r\n    \r\n    addEventToEL(el){\r\n        let onModelSet = function(ev){\r\n            let s = this.sets.find(f => f.value === ev.last);\r\n            if (s){\r\n                this.removeClass(el, s.class);\r\n            }\r\n\r\n            s = this.sets.find(f => f.value === ev.value);\r\n            if (s){\r\n                this.addClass(el, s.class);\r\n            }\r\n        }.bind(this);\r\n        \r\n        let onClick = function(){\r\n            let k = this.skeys.indexOf( this.modelRel.value )+1;\r\n\r\n            if (!this.skeys[k]){k = 0;}\r\n\r\n            this.modelRel.value = this.skeys[k];\r\n        }.bind(this);\r\n        \r\n        this.modelRel.onSet( onModelSet, this);\r\n        el.addEventListener('click', onClick, false);\r\n\r\n        this.skeys.forEach(v => this.removeClass(el, this.sets[v]));\r\n        \r\n        onModelSet({last: null, value: this.modelRel.value});\r\n    }\r\n\r\n    clearEvents(DOMel){\r\n        this.modelRel.off( this );\r\n    }\r\n\r\n    constructor(DOMFind, modelRel, sets){\r\n        super(DOMFind);\r\n        \r\n        this.modelRel = modelRel;\r\n        this.sets = sets?sets:[\r\n            {value: false, class: 'off'},\r\n            {value: true, class: 'on'}\r\n        ];\r\n        this.skeys = this.sets.map(s => s.value);\r\n    }\r\n}\r\n\r\nclass zzLinkCheckboxValue extends zzLinkFind{\r\n    addEventToEL(el){\r\n        let onModelSet = function(ev){\r\n            if (el.value){\r\n                el.checked = (ev.value === el.value);\r\n            }else{\r\n                el.checked = ev.value?true:false;\r\n            }\r\n        }.bind(this);\r\n        \r\n        let onClick = function(e){\r\n            if (el.checked){\r\n                this.modelRel.value = el.value?el.value:true;\r\n            }else{\r\n                this.modelRel.value = el.value?'':false;\r\n            }\r\n        }.bind(this);\r\n        \r\n        this.modelRel.onSet( onModelSet, this);\r\n        el.addEventListener('click', onClick, false);\r\n\r\n        onModelSet({last: null, value: this.modelRel.value});\r\n    }\r\n\r\n    clearEvents(DOMel){\r\n        this.modelRel.off( this );\r\n    }\r\n\r\n    constructor(DOMFind, modelRel){\r\n        super(DOMFind);\r\n        \r\n        this.modelRel = modelRel;\r\n    }\r\n}\r\n\r\nclass zzLinkSelectValue extends zzLinkFind{\r\n    removeClass(el, className){\r\n        let cels = el.className.split(' ');\r\n        let i = cels.indexOf(className);\r\n        if (i !== -1){\r\n            cels.splice(i, 1);\r\n            el.className = cels.join(' ');\r\n        }\r\n    }\r\n    \r\n    addClass(el, className){\r\n        let cels = el.className.split(' ');\r\n        cels.push(className);\r\n        el.className = cels.join(' ');\r\n    }\r\n    \r\n    addEventToEL(el){\r\n        let onModelSet = function(ev){\r\n            let value = el.getAttribute(this.attrName) || (el.dataset[this.attrName]);\r\n            if (value){\r\n                if (ev.value === value){\r\n                    this.addClass(el, this.className);\r\n                }else{\r\n                    this.removeClass(el, this.className);\r\n                }\r\n            }else if (!ev.value){\r\n                this.addClass(el, this.className);\r\n            }else{\r\n                this.removeClass(el, this.className);\r\n            }\r\n        }.bind(this);\r\n        \r\n        let onClick = function(e){\r\n            let value = el.getAttribute(this.attrName) || (el.dataset[this.attrName]);\r\n            if (value){\r\n                this.modelRel.value = value;\r\n            }else{\r\n                this.modelRel.value = false;\r\n            }\r\n        }.bind(this);\r\n        \r\n        this.modelRel.onSet( onModelSet, this);\r\n        el.addEventListener('click', onClick, false);\r\n\r\n        onModelSet({last: null, value: this.modelRel.value});\r\n    }\r\n\r\n    clearEvents(DOMel){\r\n        this.modelRel.off( this );\r\n    }\r\n\r\n    constructor(DOMFind, modelRel, className, attrName){\r\n        super(DOMFind);\r\n        \r\n        this.modelRel = modelRel;\r\n        this.className = className;\r\n        this.attrName = attrName || 'value';\r\n    }\r\n}\r\n\r\nclass zzLinkAttributeValue extends zzLinkFind{\r\n    setupAttr(attr, modelArr, el){\r\n        var DOMAttr = document.createAttribute(attr);\r\n        el.setAttributeNode( DOMAttr );\r\n\r\n        let dfn = () => {\r\n            let value = '';\r\n\r\n            for (let model of modelArr){\r\n                if (model instanceof zzReference){\r\n                    value += model.value;\r\n                }else{\r\n                    value += model;\r\n                }\r\n            }\r\n            \r\n            DOMAttr.value = value;\r\n        };\r\n        \r\n        for (let model of modelArr){\r\n            if (model instanceof zzReference){\r\n                model.onSet(dfn, this);\r\n            }\r\n        }\r\n        \r\n        dfn();\r\n    }\r\n    \r\n    addEventToEL(el){\r\n        for (let name in this.attr){\r\n            this.setupAttr(name, this.attr[name], el);\r\n        }\r\n    }\r\n\r\n    clearEvents(){\r\n        for (let name in this.attr){\r\n            for (let model of this.attr[name]){\r\n                if (model instanceof zzReference){\r\n                    model.off( this );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    constructor(DOMFind, attr, modelRel){\r\n        super(DOMFind);\r\n\r\n        if (typeof attr === 'string'){\r\n            !Array.isArray(modelRel) && (modelRel = [modelRel]);\r\n            this.attr = {};\r\n            this.attr[attr] = modelRel;\r\n        }else{\r\n            for (let name in attr){\r\n                !Array.isArray(attr[name]) && (attr[name] = [attr[name]]);\r\n                this.attr = attr;\r\n            }            \r\n        }\r\n    }\r\n}\r\n\r\nclass zzLinkStyleValue extends zzLinkAttributeValue{\r\n    setupAttr(style, modelArr, el){\r\n        let dfn = () => {\r\n            let value = '';\r\n\r\n            for (let model of modelArr){\r\n                if (model instanceof zzReference){\r\n                    value += model.value;\r\n                }else{\r\n                    value += model;\r\n                }\r\n            }\r\n            \r\n            el.style[style] = value;\r\n        };\r\n        \r\n        for (let model of modelArr){\r\n            if (model instanceof zzReference){\r\n                model.onSet(dfn, this);\r\n            }\r\n        }\r\n        \r\n        dfn();\r\n    }\r\n}\r\n\r\nclass zzLinkClassValue extends zzLinkFind{\r\n    addEventToEL(el){\r\n        let listener = function(event){\r\n            var cels = el.className.split(' ');\r\n            \r\n            if (event.last){\r\n                var remove = event.last.split(' ');\r\n                for (var r in remove){\r\n                    let i = cels.indexOf(remove[r]);\r\n                    if (i !== -1){\r\n                        cels.splice(i, 1);\r\n                    }            \r\n                }\r\n            }\r\n\r\n            cels.push(event.value);\r\n\r\n            el.className = cels.join(' ').replace(/\\s+/gmi,' ');\r\n        };\r\n\r\n        this.modelRel.onSet( listener, this);\r\n        \r\n        listener({\r\n            last: null,\r\n            value: this.modelRel.value\r\n        });\r\n    }\r\n\r\n    clearEvents(DOMel){\r\n        this.modelRel.off( this );\r\n    }\r\n\r\n    constructor(DOMFind, modelRel){\r\n        super(DOMFind);\r\n        \r\n        this.modelRel = modelRel;\r\n    }\r\n}\r\n\r\nclass zzLinkClassObjectValue extends zzLinkFind{\r\n    setupClass(className, model, el){\r\n        if (model instanceof zzReference){\r\n            let listener = function(event){\r\n                var cels = el.className.split(' ');\r\n\r\n                var remove = className.split(' ');\r\n                for (var r in remove){\r\n                    let i = cels.indexOf(remove[r]);\r\n                    if (i !== -1){\r\n                        cels.splice(i, 1);\r\n                    }            \r\n                }\r\n\r\n                if (event.value){\r\n                    cels.push(className);\r\n                }\r\n\r\n                el.className = cels.join(' ').replace(/\\s+/gmi,' ');\r\n            };\r\n\r\n            model.onSet( listener, this);\r\n\r\n            listener({\r\n                last: null,\r\n                value: model.value\r\n            });\r\n        }else if (typeof model === 'string'){\r\n            el.className += ' '+model;\r\n        }\r\n    }\r\n    \r\n    addEventToEL(el){\r\n        for (let name in this.classes){\r\n            this.setupClass(name, this.classes[name], el);\r\n        }\r\n    }\r\n\r\n    clearEvents(field){\r\n        for (let name in this.classes){\r\n            if (this.classes[name] instanceof zzReference){\r\n                this.classes[name].off( this );\r\n            }\r\n        }\r\n    }\r\n\r\n    constructor(DOMFind, classes){\r\n        super(DOMFind);\r\n        \r\n        this.classes = classes;\r\n    }\r\n}\r\n\r\nclass zzLinkClick extends zzLinkFind{\r\n    addEventToEL(el, DOMfield){\r\n        el.addEventListener('click', this.fn.bind(this.self?this.self:DOMfield, el, DOMfield));\r\n    }\r\n\r\n    constructor(DOMFind, fn, self){\r\n        super(DOMFind);\r\n        \r\n        this.fn = fn;\r\n        this.self = self;\r\n    }\r\n}\r\n\r\nclass zzLinkIf extends zzLinkFind{\r\n    addEventToEL(el){\r\n        let DOMEmpty = document.createTextNode('');\r\n        el.parentNode.insertBefore(DOMEmpty, el);\r\n        \r\n        let listener = function(event){\r\n            let visible = Boolean(event.value);\r\n            if (Boolean(event.last) !== visible){\r\n                if (visible){\r\n                    DOMEmpty.parentNode.insertBefore(el, DOMEmpty);\r\n                }else{\r\n                    el.remove();\r\n                }\r\n            }\r\n        };\r\n\r\n        this.modelRel.onSet( listener, this);\r\n        \r\n        listener({\r\n            last: true,\r\n            value: this.modelRel.value\r\n        });\r\n    }\r\n\r\n    clearEvents(DOMel){\r\n        this.modelRel.off( this );\r\n    }\r\n\r\n    constructor(DOMFind, modelRel){\r\n        super(DOMFind);\r\n        \r\n        this.modelRel = modelRel;\r\n    }\r\n}\r\n\r\nclass zzLinkRoute extends zzLinkFind{\r\n    getValue(v){\r\n        return '/'+(Array.isArray(v)?v.join('/'):v);\r\n    }\r\n    \r\n    addEventToEL(el){\r\n        var DOMAttr = document.createAttribute('href');\r\n        el.setAttributeNode( DOMAttr );\r\n\r\n        el.addEventListener('click', function(ev){\r\n            ev.preventDefault();\r\n            Router.go((this.modelRel instanceof zzReference)?this.modelRel.value:this.modelRel);\r\n        }.bind(this));\r\n        \r\n        if (this.modelRel instanceof zzReference){\r\n            this.modelRel.onSet( function(){\r\n                DOMAttr.value = this.getValue(this.modelRel.value);\r\n            }, this).run();\r\n        }else{\r\n            DOMAttr.value = this.getValue(this.modelRel);\r\n        }\r\n    }\r\n\r\n    clearEvents(DOMel){\r\n        if (this.modelRel instanceof zzReference){\r\n            this.modelRel.off( this );\r\n        }\r\n    }\r\n        \r\n    constructor(DOMFind, modelRel){\r\n        super(DOMFind);\r\n        \r\n        this.modelRel = modelRel;\r\n    }\r\n}\r\n\r\nclass zzLinkRouteHref extends zzLinkFind{\r\n    addEventToEL(el){\r\n        el.addEventListener('click', function(ev){\r\n            ev.preventDefault();\r\n            Router.go( el.getAttribute( 'href' ) );\r\n        }.bind(this));\r\n    }\r\n\r\n    clearEvents(DOMel){\r\n        if (this.modelRel instanceof zzReference){\r\n            this.modelRel.off( this );\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    __zzViewAddon:{\r\n        /* shortcuts */\r\n        preventSubmit(DOMFind){\r\n           return this.link( new zzLinkPreventSubmit(DOMFind) );\r\n        },\r\n        input(DOMFind, modelRel, changeFn){\r\n           return this.link( new zzLinkInputValue(DOMFind, modelRel, changeFn) );\r\n        },\r\n        inputInteger(DOMFind, modelRel){\r\n           return this.input(DOMFind, modelRel, (value) => {\r\n                let val = parseInt(value);\r\n                return isNaN(val)?undefined:val;\r\n           });\r\n        },\r\n        inputFloat(DOMFind, modelRel){\r\n           return this.input(DOMFind, modelRel, (value) => {\r\n                let val = parseFloat(value);\r\n                return isNaN(val)?undefined:val;\r\n           });\r\n        },\r\n        checkbox(DOMFind, modelRel, sets){\r\n           return this.link( new zzLinkCheckboxValue(DOMFind, modelRel, sets) );\r\n        },\r\n        radio(DOMFind, modelRel, sets){\r\n           return this.link( new zzLinkCheckboxValue(DOMFind, modelRel, sets) );\r\n        },\r\n        select(DOMFind, modelRel, className, attrName){\r\n           return this.link( new zzLinkSelectValue(DOMFind, modelRel, className, attrName) );\r\n        },\r\n        autoResizeTextarea(DOMFind){\r\n           return this.link( new zzLinkAutoResizeTextarea(DOMFind) );\r\n        },\r\n        text(DOMFind, modelRel, append){\r\n           return this.link( new zzLinkTextValue(DOMFind, modelRel, append) );\r\n        },\r\n        html(DOMFind, modelRel){\r\n           return this.link( new zzLinkHtmlValue(DOMFind, modelRel) );\r\n        },\r\n        switch(DOMFind, modelRel, sets){\r\n           return this.link( new zzLinkSwitchValue(DOMFind, modelRel, sets) );\r\n        },\r\n        attr(DOMFind, attrName, modelRel){\r\n            return this.link( new zzLinkAttributeValue(DOMFind, attrName, modelRel) );\r\n        },\r\n        style(DOMFind, cssName, modelRel){\r\n            return this.link( new zzLinkStyleValue(DOMFind, cssName, modelRel) );\r\n        },\r\n        class(DOMFind, modelRel){\r\n            if (typeof modelRel === 'string' || modelRel instanceof zzReference){\r\n                return this.link( new zzLinkClassValue(DOMFind, modelRel) );\r\n            }else{\r\n                return this.link( new zzLinkClassObjectValue(DOMFind, modelRel) );\r\n            }\r\n        },\r\n        click(DOMFind, fn, self){\r\n            return this.link( new zzLinkClick(DOMFind, fn, self) );\r\n        },\r\n        if(DOMFind, modelRel){\r\n            return this.link( new zzLinkIf(DOMFind, modelRel) );\r\n        },\r\n        route(DOMFind, data){\r\n            if (data === undefined){\r\n                return this.link( new zzLinkRouteHref(DOMFind) );\r\n            }else{\r\n                return this.link( new zzLinkRoute(DOMFind, data) );\r\n            }\r\n        }    \r\n    }\r\n};\r\n\n\n//# sourceURL=webpack:///../libs/lizzi/DOM/default.js?");

/***/ }),

/***/ "../libs/lizzi/DOM/index.js":
/*!**********************************!*\
  !*** ../libs/lizzi/DOM/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\r\n * Docs https://github.com/myrpg-fun/lizzi\r\n */\r\n\r\nlet {zzReference, Collection, LazyCollection} = __webpack_require__(/*! ../index */ \"../libs/lizzi/index.js\");\r\nlet {Event, EventListener} = __webpack_require__(/*! ../Event */ \"../libs/lizzi/Event.js\");\r\nlet {zzLink, zzLinkFind} = __webpack_require__(/*! ./zzLink */ \"../libs/lizzi/DOM/zzLink.js\");\r\n\r\nclass zzCollectionDOM{\r\n    replace(newValues){\r\n        let newViewComponent = [];\r\n        this.nodes.forEach((d, i) => d.data.__zzIndeX = i);\r\n        \r\n        if (newValues.length > 0){\r\n            let maxIndex = this.nodes.length;\r\n            let nodeBefore = null;\r\n            \r\n            let aValues;\r\n            \r\n            if (Array.isArray(newValues)){\r\n                aValues = newValues;\r\n            }else if (newValues instanceof LazyCollection || newValues instanceof Collection){\r\n                aValues = newValues.toArray();\r\n            }else{\r\n                aValues = [];\r\n            }\r\n            \r\n            for (let i = aValues.length - 1; i >= 0; i--){\r\n                let data = aValues[i];\r\n                \r\n                if (!data){\r\n                    continue;\r\n                }\r\n                \r\n                let node = null;\r\n                if ('__zzIndeX' in data){\r\n                    let index = data.__zzIndeX;\r\n                    node = this.nodes[index].node;\r\n                    \r\n                    if (index < maxIndex){\r\n                        maxIndex = index;\r\n                    }else{\r\n                        node.appendTo(this.DOM, nodeBefore);\r\n                    }\r\n                        \r\n                    delete data.__zzIndeX;\r\n                }else{\r\n                    if (data instanceof ViewComponent){\r\n                        node = data;\r\n                    }else if (data && data[this.fnname]){\r\n                        node = data[this.fnname].call(data);\r\n                    }\r\n                    \r\n                    if (node instanceof ViewComponent){\r\n                        node.appendTo(this.DOM, nodeBefore);\r\n                    }\r\n                }\r\n                \r\n                if (node instanceof ViewComponent){\r\n                    nodeBefore = node;\r\n//                    node.appendTo(this.DOM);\r\n\r\n                    newViewComponent.unshift({\r\n                        data: data,\r\n                        node: node\r\n                    });\r\n                }\r\n            };\r\n        }\r\n        \r\n        let removeSort = this.nodes.slice(0);\r\n        for (let f of removeSort){\r\n            if ('__zzIndeX' in f.data){\r\n                delete f.data.__zzIndeX;\r\n                f.node.removeDOM();\r\n            }\r\n        }            \r\n        \r\n        this.nodes = newViewComponent;\r\n    }\r\n    \r\n    remove(element, index){\r\n        if (this.nodes[index]){\r\n            if (this.nodes[index].data !== element){\r\n                console.error(\"Unsynced data found\");\r\n                return;\r\n            }\r\n            \r\n            this.nodes.splice(index, 1)[0].node.removeDOM();\r\n        }\r\n    }\r\n    \r\n    add(data, idx){\r\n        if (data[this.fnname]){\r\n            let node = data[this.fnname].call(data);\r\n            if (node){\r\n                node.appendTo(this.DOM, this.nodes[idx]?this.nodes[idx].node:null);\r\n\r\n                this.nodes.splice(idx, 0, {\r\n                    data: data,\r\n                    node: node\r\n                });\r\n            }\r\n        }\r\n    }\r\n    \r\n    removeDOM(){\r\n        this.collection.off(this);\r\n\r\n        this.nodes.forEach(function(node){\r\n            node.node.removeDOM();\r\n        });       \r\n        \r\n        //this.DOM.remove();\r\n        this.collection = null;\r\n    }\r\n    \r\n    connectDOM(collection){\r\n        if (!(collection instanceof Collection) && !(collection instanceof LazyCollection)){\r\n            console.error('Error: '+collection+' is not Collection');\r\n            return;\r\n        }\r\n        \r\n        this.collection = collection;\r\n        this.collection.on('add', this.add, this);\r\n        this.collection.on('remove', this.remove, this);\r\n        this.collection.on('replace-values', this.replace, this);\r\n        this.replace( collection.elements, this );\r\n    }\r\n    \r\n    constructor(Template, collection, fnname){\r\n        this.nodes = [];\r\n        this.DOM = Template;\r\n        this.fnname = fnname;\r\n        \r\n        this.connectDOM(collection);\r\n    }\r\n}\r\n\r\nclass zzLinkCollection extends zzLinkFind{\r\n    addEventToEL(el){\r\n        this.added.push(\r\n            new zzCollectionDOM(new Template(el), this.collection, this.fnname)\r\n        );\r\n    }\r\n\r\n    clearEvents(DOMel){\r\n        for (let i in this.added){\r\n            this.added[i].removeDOM();\r\n        }\r\n        \r\n        this.added = [];\r\n    }\r\n\r\n    constructor(DOMFind, collection, fnname){\r\n        super(DOMFind);\r\n        \r\n        if (!(collection instanceof Collection) && !(collection instanceof LazyCollection)){\r\n            console.error('Error: linked collection is not Collection');\r\n        }\r\n        \r\n        this.collection = collection;\r\n        this.fnname = fnname;\r\n        this.added = [];\r\n    }\r\n}\r\n\r\nclass zzCollectionAnimationDOM extends zzCollectionDOM{\r\n    replace(newValues){        \r\n        let newViewComponent = [];\r\n        this.nodes.forEach((d, i) => d.data.__zzIndeX = i);\r\n                \r\n        if (newValues.length > 0){\r\n            for (let data of newValues){\r\n                if (!data){\r\n                    continue;\r\n                }\r\n                \r\n                let node = null;\r\n                if ('__zzIndeX' in data){\r\n                    node = this.nodes[data.__zzIndeX].node;\r\n                    delete data.__zzIndeX;\r\n                }else{\r\n                    if (data instanceof ViewComponent){\r\n                        node = data;\r\n                    }else if (data && data[this.fnname]){\r\n                        node = data[this.fnname].call(data);\r\n                    }\r\n                    \r\n                    if (node instanceof ViewComponent){\r\n                        //only if new\r\n                        node.appendTo(this.DOM);\r\n                    }\r\n                }\r\n                \r\n                if (node instanceof ViewComponent){\r\n                    newViewComponent.push({\r\n                        data: data,\r\n                        node: node\r\n                    });\r\n                }\r\n            };\r\n        }\r\n        \r\n        let removeSort = this.nodes;//.slice(0);\r\n        for (let f of removeSort){\r\n            if ('__zzIndeX' in f.data){\r\n                delete f.data.__zzIndeX;\r\n                f.node.removeDOM();\r\n            }\r\n        }            \r\n        \r\n        this.nodes = newViewComponent;\r\n    }\r\n}\r\n\r\nclass zzLinkCollectionAnimation extends zzLinkCollection{\r\n    addEventToEL(el){\r\n        this.added.push(\r\n            new zzCollectionAnimationDOM(new Template(el), this.collection, this.fnname)\r\n        );\r\n    }\r\n}\r\n\r\nclass zzLinkData extends zzLinkFind{\r\n    async removeDOM(){\r\n        if (this.added.length > 0){\r\n            let l;\r\n            for (let i in this.added){\r\n                l = this.added[i].removeDOM();\r\n            }\r\n            await l;\r\n        }\r\n        \r\n        this.added = [];\r\n    }\r\n    \r\n    addDOM(data, el){\r\n        if (data && data[this.fnname]){\r\n            const node = data[this.fnname].call(data);\r\n\r\n            if (node instanceof ViewComponent){\r\n                node.appendTo(el);\r\n                \r\n                this.added.push(\r\n                    node\r\n                );\r\n            }\r\n        }\r\n    }\r\n    \r\n    addEventToEL(el){\r\n        const DataRef = this.modelRel;\r\n        \r\n        if (DataRef instanceof zzReference){\r\n            const data = DataRef.value;\r\n            this.addDOM(data, el);\r\n\r\n            let inside = false;\r\n            DataRef.onSet(async function(){\r\n                if (!inside){\r\n                    inside = true;\r\n                    await this.removeDOM();\r\n\r\n                    this.addDOM(DataRef.value, el);\r\n                    inside = false;\r\n                }\r\n            }, this);\r\n        }else{\r\n            this.addDOM(DataRef, el);\r\n        }\r\n    }\r\n\r\n    clearEvents(DOMel){\r\n        if (this.modelRel){\r\n            this.modelRel.off(this);\r\n        }\r\n    }\r\n\r\n    constructor(DOMFind, modelRel, fnname){\r\n        super(DOMFind);\r\n        \r\n        this.modelRel = modelRel;\r\n        this.fnname = fnname;\r\n        this.added = [];\r\n    }\r\n}\r\n\r\nclass zzLinkViewComponent extends zzLinkFind{\r\n    async removeDOM(node){\r\n        if (node instanceof ViewComponent){\r\n            await node.removeDOM();\r\n        }\r\n    }\r\n    \r\n    addDOM(node, el){\r\n        if (node instanceof ViewComponent){\r\n            node.appendTo(el);\r\n        }\r\n    }\r\n    \r\n    addEventToEL(el){\r\n        const node = this.node;\r\n        \r\n        if (node instanceof zzReference){\r\n            this.addDOM(node.value, el);\r\n\r\n            let inside = false;\r\n            node.onSet(async function(ev){\r\n                if (!inside){\r\n                    inside = true;\r\n                    if (ev.last instanceof ViewComponent){\r\n                        await this.removeDOM(ev.last);\r\n                    }\r\n\r\n                    this.addDOM(node.value, el);\r\n                    inside = false;\r\n                }\r\n            }, this);\r\n        }else if(node instanceof ViewComponent){\r\n            this.addDOM(node, el);\r\n        }\r\n    }\r\n\r\n    clearEvents(){\r\n        const node = this.node;\r\n        \r\n        if (node instanceof zzReference){\r\n            this.removeDOM(node.value);\r\n            node.off(this);\r\n        }else if(node instanceof ViewComponent){\r\n            this.removeDOM(node);\r\n        }\r\n    }\r\n\r\n    constructor(DOMFind, node){\r\n        super(DOMFind);\r\n        \r\n        if (!(node instanceof ViewComponent || node instanceof zzReference)){\r\n            console.error('Error: linked node is not ViewComponent or not zzReference');\r\n        }\r\n        \r\n        this.node = node;\r\n    }\r\n}\r\n\r\nclass zzInitialize extends zzLink{\r\n    addEvents(DOMnode){\r\n        if (this.initFn){\r\n            this.initFn(DOMnode);\r\n        }\r\n    }\r\n\r\n    async clearEvents(DOMnode){\r\n        if (this.destroyFn){\r\n            await this.destroyFn(DOMnode);\r\n        }\r\n    }\r\n\r\n    constructor(initFn, destroyFn){\r\n        super();\r\n        \r\n        this.initFn = initFn;\r\n        this.destroyFn = destroyFn;\r\n    }\r\n}\r\n\r\nclass zzLinkOn extends zzLink{\r\n    addEvents(view){\r\n        if (typeof this.self === 'string'){\r\n            this.self = view.find(this.self).elements[0];\r\n        }\r\n        \r\n        let fn = this.self.on || this.self.addEventListener || this.self.addListener;\r\n        \r\n        this.initEv = fn(this.eventName, this.listenerFn.bind(view));\r\n        if (this.isRun){\r\n            this.listenerFn.apply(view, this.isRun);\r\n        }\r\n    }\r\n\r\n    clearEvents(view){\r\n        if (this.initEv){\r\n            let fn = this.initEv.off || this.initEv.removeEventListener || this.initEv.removeListener;\r\n            fn(this.eventName, this.listenerFn);\r\n        }\r\n    }\r\n\r\n    constructor(self, eventName, listenerFn, isRun){\r\n        super();\r\n        \r\n        this.initEv = null;\r\n        this.listenerFn = listenerFn;\r\n        this.eventName = eventName;\r\n        this.self = self;\r\n        this.isRun = isRun;\r\n    }\r\n}\r\n\r\nclass Template{\r\n    children(){\r\n        let result = [];\r\n        for (let i in this.__zzElements){\r\n            if (this.__zzElements[i].content){\r\n                result = result.concat(Array.prototype.slice.call(this.__zzElements[i].content.childNodes));\r\n            }else if (this.__zzElements[i].childNodes){\r\n                result = result.concat(Array.prototype.slice.call(this.__zzElements[i].childNodes));\r\n            }\r\n        }\r\n        \r\n        return new Template(result);\r\n    }\r\n    \r\n    html(){\r\n        return this.__zzElements.map(el => el.innerHTML).join('');\r\n    }\r\n    \r\n    parse(){\r\n        return new Template(this.html());\r\n    }\r\n    \r\n    find(selector){\r\n        let result = [];\r\n        for (let i in this.__zzElements){\r\n            let el = this.__zzElements[i];\r\n            if (el instanceof Element){\r\n                result = result\r\n                    .concat(Array.prototype.slice.call(el.querySelectorAll(selector)))\r\n                    .concat(el.matches(selector)?[el]:[]);\r\n            }\r\n        }\r\n        \r\n        if (result.length === 0){\r\n            console.error('Template can not find:', selector);\r\n        }\r\n        \r\n        return new Template(result);\r\n    }\r\n\r\n    __zzConvert(template){\r\n        if (template instanceof Template){\r\n            return template.__zzElements;\r\n        }\r\n        \r\n        if (typeof template === 'string'){\r\n            if (template.indexOf('<') !== -1){\r\n                try {\r\n                    template = (new DOMParser).parseFromString(template, 'text/html');\r\n                    return []\r\n                        .concat(Array.prototype.slice.call(template.head.childNodes))\r\n                        .concat(Array.prototype.slice.call(template.body.childNodes));\r\n                }catch(err){\r\n                    console.error(err);\r\n                    return [];\r\n                }\r\n            }else{\r\n                template = document.querySelectorAll(template);\r\n            }\r\n        }\r\n        \r\n        if (template instanceof NodeList){\r\n            return Array.prototype.slice.call(template);\r\n        }\r\n        \r\n        if (template === undefined){\r\n            template = document.documentElement;\r\n        }\r\n        \r\n        if (template instanceof Document){\r\n            template = template.documentElement;\r\n        }\r\n        \r\n        if (template instanceof Node){\r\n            return [template];\r\n        }\r\n        \r\n        return [];\r\n    }\r\n    \r\n    append(DOMElement){\r\n        let appendTo = this.__zzElements.find(el => el instanceof Node && !(el instanceof Text));\r\n        if (appendTo){\r\n            //append to first DOM element\r\n            DOMElement = this.__zzConvert(DOMElement);\r\n\r\n            for (let i in DOMElement){\r\n                if (!(DOMElement[i] instanceof Document)){\r\n                    appendTo.appendChild(DOMElement[i]);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    \r\n    appendBefore(DOMElement, BeforeElement){\r\n        let appendTo = this.__zzElements.find(el => el instanceof Node && !(el instanceof Text));\r\n        if (appendTo){\r\n            //append to first DOM element\r\n            DOMElement = this.__zzConvert(DOMElement);\r\n\r\n            for (let i in DOMElement){\r\n                if (!(DOMElement[i] instanceof Document)){\r\n                    if (BeforeElement instanceof Template){\r\n                        BeforeElement = BeforeElement[0];\r\n                    }\r\n                    \r\n                    appendTo.insertBefore(DOMElement[i], BeforeElement?BeforeElement:null);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    \r\n    remove(){\r\n        for (let el of this.__zzElements){\r\n            if (el.parentNode){\r\n                el.parentNode.removeChild( el );\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    \r\n    clone(){\r\n        return new Template( this.__zzElements.map( el => el.cloneNode(true) ) );\r\n    }\r\n    \r\n    *[Symbol.iterator] () {\r\n        for (let el of this.__zzElements){\r\n            yield el;\r\n        }\r\n    }\r\n\r\n    toArray(){\r\n        return this.__zzElements;\r\n    }\r\n    \r\n    createView(selector, data){\r\n        return new ViewComponent( (selector === null)? this : this.find(selector), data);\r\n    }\r\n    \r\n    constructor(template){\r\n        !Array.isArray(template) && (template = [template]);\r\n        \r\n        Object.defineProperty(this, 'length', {\r\n            get: () => this.__zzElements.length\r\n        });\r\n\r\n        Object.defineProperty(this, 'elements', {\r\n            get: () => this.__zzElements\r\n        });\r\n        \r\n        this.__zzElements = [];\r\n        let index = 0;\r\n        for (let t of template){\r\n            let elements = this.__zzConvert( t );\r\n            for (let el of elements){\r\n                this[index++] = el;\r\n                this.__zzElements.push(el);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass ViewComponent extends Event{\r\n    async removeDOM(){\r\n        if (this.__zzRemoveDOM){\r\n            this.__zzRemoveDOM = false;\r\n            await this.clearEvents();\r\n\r\n            this.DOM.remove();\r\n            this.__zzRemoveDOM = true;\r\n        }\r\n        return this;\r\n    }\r\n    \r\n    appendTo(DOMElement, BeforeElement){\r\n        if (!(DOMElement instanceof Template)){\r\n            DOMElement = new Template(DOMElement);\r\n        }\r\n        \r\n        if (DOMElement.length > 0){\r\n            if (BeforeElement instanceof ViewComponent){\r\n                BeforeElement = BeforeElement.DOM;\r\n            }\r\n            \r\n            this.addEvents();\r\n\r\n            DOMElement.appendBefore( this.DOM, BeforeElement );\r\n        }\r\n    }\r\n    \r\n    collection(DOMFind, collection, fnname, animation){\r\n        if (animation === true){\r\n            return this.link( new zzLinkCollectionAnimation(DOMFind, collection, fnname) );\r\n        }\r\n        \r\n        return this.link( new zzLinkCollection(DOMFind, collection, fnname) );\r\n    }\r\n    \r\n    view(DOMFind, component){\r\n        return this.link( new zzLinkViewComponent(DOMFind, component) );\r\n    }    \r\n    \r\n    data(DOMFind, data, fnname){\r\n        return this.link( new zzLinkData(DOMFind, data, fnname) );\r\n    }\r\n    \r\n    init(initFn, destroyFn){\r\n        return this.link( new zzInitialize(initFn, destroyFn) );\r\n    }\r\n    \r\n    on(self, eventName, listenerFn, isRun){\r\n        return this.link( new zzLinkOn(self, eventName, listenerFn, isRun) );\r\n    }\r\n    \r\n    /* main class*/\r\n    link(zzLinkEvent){\r\n        if (zzLinkEvent instanceof zzLink){\r\n            this.events.push(zzLinkEvent);\r\n        }\r\n        return this;\r\n    }\r\n    \r\n    addEvents(){\r\n        if (this.__zzClearEvents === false){\r\n            this.emit('add-events', this);\r\n            for (let eventFn of this.events){\r\n                eventFn.addEvents(this);\r\n            }\r\n            \r\n            this.__zzClearEvents = true;\r\n            this.emit('after-add-events', this);\r\n        }else if (this.__zzClearEvents === null){\r\n            this.once('after-clear-events', this.addEvents, this);            \r\n        }\r\n        \r\n        return this;\r\n    }\r\n    \r\n    async clearEvents(){\r\n        if (this.__zzClearEvents === true){\r\n            this.__zzClearEvents = null;\r\n            \r\n            this.emit('clear-events', this);\r\n            for (let eventFn of this.events){\r\n                await eventFn.clearEvents(this);\r\n            }\r\n            \r\n            this.__zzClearEvents = false;\r\n            this.emit('after-clear-events', this);\r\n        }\r\n        \r\n        return this;\r\n    }\r\n    \r\n    find(selector){\r\n        var DOMel = (selector !== null)?\r\n            this.DOM.find( selector ):\r\n            this.DOM;\r\n    \r\n        if (DOMel.length === 0){\r\n            console.error('Wrong selector', selector);\r\n        }\r\n        \r\n        return DOMel;\r\n    }\r\n\r\n    static addon(file){\r\n        if (file){\r\n            for (let i in file){\r\n                if (typeof file[i] === 'function'){\r\n                    ViewComponent.prototype[i] = file[i];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    __initDOM(T){\r\n        this.DOM = new Template(T).children().clone();\r\n        \r\n    }\r\n    \r\n    /* Create Html DOM ViewComponent */\r\n    constructor(T, Data){\r\n        super();\r\n        \r\n        this.__zzRemoveDOM = true;\r\n        this.__zzClearEvents = false;\r\n        this.Data = Data;\r\n        \r\n        this.events = [];\r\n\r\n        this.__initDOM(T);\r\n    }\r\n}\r\n\r\nViewComponent.addon( __webpack_require__(/*! ./default */ \"../libs/lizzi/DOM/default.js\").__zzViewAddon );\r\n\r\nfunction Loader(html){\r\n    return new Template(html);\r\n}\r\n\r\nmodule.exports = {ViewComponent, Loader, zzLink, zzLinkFind};\n\n//# sourceURL=webpack:///../libs/lizzi/DOM/index.js?");

/***/ }),

/***/ "../libs/lizzi/DOM/zzLink.js":
/*!***********************************!*\
  !*** ../libs/lizzi/DOM/zzLink.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("class zzLink{\r\n    addEvents(Field){}\r\n    clearEvents(Field){}\r\n}\r\n\r\nclass zzLinkFind extends zzLink{\r\n    addEvents(Field){\r\n        var els = Field.find(this.find).elements;\r\n        for (let i in els){\r\n            this.addEventToEL(els[i], Field);\r\n        }\r\n    }\r\n    \r\n    clearEvents(Field){}\r\n\r\n    constructor(selector){\r\n        super();\r\n        \r\n        this.find = selector;\r\n    }\r\n}\r\n\r\nmodule.exports = {zzLink, zzLinkFind};\n\n//# sourceURL=webpack:///../libs/lizzi/DOM/zzLink.js?");

/***/ }),

/***/ "../libs/lizzi/Event.js":
/*!******************************!*\
  !*** ../libs/lizzi/Event.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\r\n * Docs https://github.com/myrpg-fun/lizzi\r\n */\r\n\r\nclass EventStack{\r\n    removeAll(){\r\n        let arr = this.events;\r\n        \r\n        for (let l in arr){\r\n            if (arr[l] instanceof EventListener){\r\n                arr[l].off();\r\n            }\r\n        }\r\n        \r\n        this.events = [];\r\n        \r\n        return this;\r\n    }\r\n    \r\n    add(events){\r\n        !Array.isArray(events) && (events = [events]);\r\n        \r\n        this.events = this.events.concat(events);\r\n        \r\n        return this;\r\n    }\r\n    \r\n    constructor(){\r\n        this.events = [];\r\n    }\r\n};\r\n\r\nclass EventAvoid{\r\n    constructor(){\r\n        let run = false;\r\n        \r\n        this.set = (fn) => {\r\n            return function(){\r\n                run = true;\r\n                fn.apply(this, arguments);\r\n                run = false;\r\n            };\r\n        };\r\n        \r\n        this.check = (fn) => {\r\n            return function(){\r\n                if (run){\r\n                    return;\r\n                }\r\n                \r\n                fn.apply(this, arguments);\r\n            };\r\n        };\r\n    }\r\n}\r\n\r\nclass EventsGroup{\r\n    add(listener, once, prepend){\r\n        let toGroup = once?this.once:this.many;\r\n        \r\n        if (listener instanceof EventListener){\r\n            if (prepend){\r\n                toGroup.unshift(listener);\r\n            }else{\r\n                toGroup.push(listener);\r\n            }\r\n            \r\n            listener.__zzAddGroup(this);\r\n        }\r\n    }\r\n    \r\n    remove(listener){\r\n        if (listener instanceof EventListener){\r\n            let i = this.once.indexOf(listener);\r\n            (i !== -1) && this.once.splice(i, 1);\r\n            \r\n            i = this.many.indexOf(listener);\r\n            (i !== -1) && this.many.splice(i, 1);\r\n        }\r\n    }\r\n    \r\n    removeFn(fn){\r\n        let i = 0;\r\n        do{\r\n            i = this.many.findIndex(l => l.fn === fn, i);\r\n            (i !== -1) && this.many.splice(i, 1);\r\n        }while(i !== -1);\r\n        \r\n        i = 0;\r\n        do{\r\n            i = this.once.findIndex(l => l.fn === fn, i);\r\n            (i !== -1) && this.once.splice(i, 1);\r\n        }while(i !== -1);\r\n    }\r\n    \r\n    removeBySelf(self){\r\n        let i = 0;\r\n        do{\r\n            i = this.many.findIndex(l => l.self === self, i);\r\n            (i !== -1) && this.many.splice(i, 1);\r\n        }while(i !== -1);\r\n        \r\n        i = 0;\r\n        do{\r\n            i = this.once.findIndex(l => l.self === self, i);\r\n            (i !== -1) && this.once.splice(i, 1);\r\n        }while(i !== -1);\r\n    }\r\n    \r\n    removeAll(){\r\n        let m = this.many;\r\n        let o = this.once;\r\n        \r\n        this.many = [];\r\n        this.once = [];\r\n        \r\n        for (let ml of m){\r\n            ml.off();\r\n        }\r\n        \r\n        for (let ol of o){\r\n            ol.off();\r\n        }\r\n        \r\n        return this;\r\n    }\r\n    \r\n    enable(args){\r\n        if (Array.isArray(args)){\r\n            this.enabled = args;\r\n        }else{\r\n            this.enabled = false;\r\n        }\r\n    }\r\n    \r\n    isEnabled(){\r\n        return this.enabled !== false;\r\n    }\r\n    \r\n    emit(argsArray){\r\n        let events = this.many.slice(0);\r\n        for (let i in events){\r\n            events[i].run(argsArray);\r\n        }\r\n\r\n        events = this.once.slice(0);\r\n        for (let i in events){\r\n            events[i].run(argsArray);\r\n        }\r\n        this.once = [];\r\n    }\r\n    \r\n    constructor(name){\r\n        this.name = name;\r\n        this.many = [];\r\n        this.once = [];\r\n        this.enabled = false;\r\n    }\r\n}\r\n\r\nclass EventListener{\r\n    off(){\r\n        for (let group of this.group){\r\n            group.remove(this);\r\n        }\r\n        \r\n        return this;\r\n    }\r\n    \r\n    run(argsArray){\r\n        if (this.isCalled){\r\n            return this;\r\n        }\r\n        \r\n        this.isCalled = true;\r\n        this.fn.apply(this.self, argsArray);\r\n        this.isCalled = false;\r\n        \r\n        return this;\r\n    }\r\n    \r\n    call(){\r\n        if (this.isCalled){\r\n            return this;\r\n        }\r\n        \r\n        this.isCalled = true;\r\n        this.fn.apply(this.self, arguments);\r\n        this.isCalled = false;\r\n        \r\n        return this;\r\n    }\r\n    \r\n    addToStack(stack){\r\n        stack.add(this);\r\n        \r\n        return this;\r\n    }\r\n\r\n    __zzAddGroup(group){\r\n        if (group instanceof EventsGroup){\r\n            this.group.push(group);\r\n        }\r\n        \r\n        return this;\r\n    }\r\n    \r\n    constructor(fn, self){\r\n        this.fn = fn;\r\n        this.self = self;\r\n        this.isCalled = false;\r\n        this.group = [];\r\n    }\r\n}\r\n\r\nclass Event{\r\n    __zzGetEvents(){\r\n        return this.__zzEvents;\r\n    }\r\n    \r\n    __zzGetEvent(name){\r\n        return this.__zzEvents[name];\r\n    }\r\n    \r\n    __zzCheckExistsEvent(name){\r\n        if (!this.__zzGetEvent(name)){\r\n            this.__zzEvents[name] = new EventsGroup(name);\r\n        }\r\n        return this.__zzEvents[name];\r\n    }\r\n    \r\n    __zzAddEventListener(name, fn, self, once, prepend){\r\n        !Array.isArray(name) && (name = [name]);\r\n        !self && (self = this);\r\n        !once && (once = false);\r\n        !prepend && (prepend = false);\r\n\r\n        let evListener;\r\n        if (fn instanceof EventListener){\r\n            evListener = fn;\r\n            self = evListener.self;\r\n            fn = evListener.fn;\r\n        }else{\r\n            evListener = new EventListener(fn, self);\r\n        }\r\n        \r\n        for (let i in name){\r\n            let evGroup = this.__zzCheckExistsEvent(name[i]);\r\n\r\n            if (evGroup.isEnabled()){\r\n                fn.apply(self, evGroup.enabled);\r\n                if (!once){\r\n                    evGroup.add(evListener, once, prepend);\r\n                }\r\n            }else{\r\n                evGroup.add(evListener, once, prepend);\r\n            }\r\n        }\r\n\r\n        return evListener;\r\n    }\r\n    \r\n    on(name, fn, self){\r\n        return this.__zzAddEventListener(name, fn, self, false, false);\r\n    }\r\n\r\n    once(name, fn, self){\r\n        return this.__zzAddEventListener(name, fn, self, true, false);\r\n    }\r\n\r\n    prependListener(name, fn, self){\r\n        return this.__zzAddEventListener(name, fn, self, false, true);\r\n    }\r\n\r\n    prependOnceListener(name, fn, self){\r\n        return this.__zzAddEventListener(name, fn, self, true, true);\r\n    }\r\n\r\n    /**\r\n     * remove event listener by name, function or class object\r\n     *\r\n     * @param {string} [name] - event name \r\n     * @param {string} [fn] - event function\r\n     * @param {string} [self] - event class object\r\n     */\r\n    off(name, fn, self){\r\n        if (name instanceof EventListener){\r\n            name.off();\r\n            \r\n            return;\r\n        }\r\n        \r\n        !Array.isArray(name) && (name = [name]);\r\n        !fn && (fn = self);\r\n\r\n        for (let i in name){\r\n            let evName = name[i];\r\n            if (typeof evName === 'string'){\r\n                let evGroup = this.__zzGetEvent(evName);\r\n\r\n                if (evGroup){\r\n                    if (typeof fn === 'function'){\r\n                        evGroup.removeFn(fn);\r\n                    }else{\r\n                        evGroup.removeBySelf(fn);\r\n                    }\r\n                }\r\n            }else{\r\n                let events = this.__zzGetEvents();\r\n                if (typeof evName === 'function'){\r\n                    for (let eventName in events){\r\n                        events[eventName].removeFn(evName);\r\n                    }\r\n                }else{\r\n                    for (let eventName in events){\r\n                        events[eventName].removeBySelf(evName);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Emit event\r\n     *\r\n     * @param   {string} name - key/index of the element in the list of jobs\r\n     */\r\n    emit(name){\r\n        let evGroup = this.__zzGetEvent(name);\r\n        if (!evGroup){\r\n            return false;\r\n        }\r\n        \r\n        evGroup.emit([].slice.call(arguments, 1));\r\n        \r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Enable event, if event enabled, all new listeners will call automatically\r\n     *\r\n     * @param   {string} name - key/index of the element in the list of jobs\r\n     */\r\n    enable(name){\r\n        let evGroup = this.__zzCheckExistsEvent(name);\r\n        evGroup.enabled = [].slice.call(arguments);\r\n        \r\n        this.emit.apply(this, evGroup.enabled);\r\n    }\r\n    \r\n    isEnabled(name){\r\n        let evGroup = this.__zzCheckExistsEvent(name);\r\n        return evGroup && evGroup.isEnabled();\r\n    }\r\n    \r\n    /**\r\n     * Disable enabled event\r\n     *\r\n     * @param   {string} name - key/index of the element in the list of jobs\r\n     */\r\n    disable(name){\r\n        let evGroup = this.__zzCheckExistsEvent(name);\r\n        if (evGroup.isEnabled()){\r\n            evGroup.enabled = false;\r\n\r\n            this.emit.apply(this, ['disable:'+name].concat([].slice.call(arguments, 1)));\r\n        }\r\n    }\r\n    \r\n    constructor(){\r\n        this.__zzEvents = {};\r\n\r\n        //aliases\r\n        this.addListener = this.on;\r\n        this.removeListener = this.off;\r\n        this.callListener = this.emit;\r\n    }\r\n};\r\n\r\nfunction EventAfterAll(fn){\r\n    var __zzAfterEmitValues = [];\r\n    \r\n    return function(){\r\n        if (__zzAfterEmitValues.length === 0){\r\n            setTimeout(() => {\r\n                fn.call(this, __zzAfterEmitValues);\r\n\r\n                __zzAfterEmitValues = [];\r\n            }, 0);\r\n\r\n            __zzAfterEmitValues.push([].slice(arguments));\r\n        }\r\n    };\r\n}\r\n\r\nmodule.exports = {EventStack, EventListener, EventsGroup, EventAfterAll, Event, EventAvoid};\r\n\n\n//# sourceURL=webpack:///../libs/lizzi/Event.js?");

/***/ }),

/***/ "../libs/lizzi/Router/index.js":
/*!*************************************!*\
  !*** ../libs/lizzi/Router/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {Data} = __webpack_require__(/*! ../index */ \"../libs/lizzi/index.js\");\r\n\r\nclass Route{\r\n    static trimPath(path){\r\n        return path.trim().replace(/[\\/\\\\]+/g, '/').replace(/^\\/+|\\/+$/g, '');\r\n    }\r\n    \r\n    __match(regexp){\r\n        return regexp;\r\n    }\r\n    \r\n    __exact(regexp){\r\n        return '^'+regexp+'$';\r\n    }\r\n    \r\n    getRegexp(route){\r\n        let result = route.matchAll(/::|\\\\:|[:?](\\w+)|\\*\\*|\\*|[.()\\\\\\/+{}^$?]|([^:.()\\\\\\/+{}^$?*]+)/gmu);\r\n        \r\n        let regexp = '';\r\n        let params = [];\r\n        \r\n        for (let r of result){\r\n            if(r[1] !== undefined){\r\n                regexp += '([\\\\p{L}\\\\p{N}:+%_-]+)';\r\n                params.push(r[1]);\r\n            }else if(r[2] !== undefined){\r\n                regexp += r[2];\r\n            }else if (r[0] === '*'){\r\n                regexp += '[^./]+';\r\n            }else if (r[0] === '**'){\r\n                regexp += '.*';\r\n            }else{\r\n                regexp += '\\\\'+r[0];\r\n            }\r\n        }\r\n        \r\n        return { params, \r\n            regexp: new RegExp(this.__match(regexp), 'mu'), \r\n            exact: new RegExp(this.__exact(regexp), 'mu') \r\n        };\r\n    }\r\n    \r\n    async runMatch(route){\r\n        let exact = this.exact.test(route);\r\n        \r\n        let match = route.match(this.regexp);\r\n        \r\n//        console.log(route, this.route, this.regexp, match, exact);\r\n        \r\n        if (match !== null){\r\n            if (!this.match){\r\n                //run one time\r\n                this.match = true;\r\n                let params = {};\r\n                for (let k in this.params){\r\n                    params[this.params[k]] = match[k*1+1];\r\n                }\r\n\r\n                if (typeof this.listener === 'function'){\r\n                    await this.listener.call(this.self, params, this);\r\n                }\r\n            }\r\n        }else{\r\n            this.match = false;\r\n        }\r\n        \r\n        return exact;\r\n    }\r\n    \r\n    runWildCard(){}\r\n    \r\n    add(route, listener, self){\r\n        return this.Router.add(this.route+'/'+route, listener, self);\r\n    }\r\n    \r\n    exactMatch(route, listener, self){\r\n        return this.Router.exactMatch(this.route+'/'+route, listener, self);\r\n    }\r\n    \r\n    noMatch(listener, self){\r\n        return this.Router.noMatch(listener, self);\r\n    }\r\n    \r\n    constructor(router, route, listener, self){\r\n        this.Router = router;\r\n        this.listener = listener;\r\n        this.self = self;\r\n        this.route = Route.trimPath(route);\r\n        this.match = false;\r\n    }\r\n}\r\n\r\nclass RouteFromStart extends Route{\r\n    __match(regexp){\r\n        return '^'+regexp;\r\n    }\r\n    \r\n    constructor(router, route, listener, self){\r\n        super(router, route, listener, self);\r\n        \r\n        let p = this.getRegexp(route);\r\n\r\n        this.regexp = p.regexp;\r\n        this.exact = p.exact;\r\n        this.params = p.params;\r\n    }\r\n}\r\n\r\nclass RouteUntilEnd extends Route{\r\n    __match(regexp){\r\n        return regexp+'$';\r\n    }\r\n    \r\n    constructor(router, route, listener, self){\r\n        super(router, route, listener, self);\r\n        \r\n        let p = this.getRegexp(route);\r\n\r\n        this.regexp = p.regexp;\r\n        this.exact = p.exact;\r\n        this.params = p.params;\r\n    }\r\n}\r\n\r\nclass RouteExactMatch extends Route{\r\n    __match(regexp){\r\n        return '^'+regexp+'$';\r\n    }\r\n    \r\n    constructor(router, route, listener, self){\r\n        super(router, route, listener, self);\r\n        \r\n        let p = this.getRegexp(route);\r\n\r\n        this.regexp = p.regexp;\r\n        this.exact = p.exact;\r\n        this.params = p.params;\r\n    }\r\n}\r\n\r\nclass RouteNoMatch extends Route{\r\n    async runMatch(route){\r\n        return false;\r\n    }\r\n    \r\n    runWildCard(){\r\n        this.listener.call(this.self, this);\r\n    }\r\n    \r\n    constructor(router, listener, self){\r\n        super(router, '', listener, self);\r\n    }\r\n}\r\n\r\nclass Router extends Data{\r\n    __zzAddRoute(newRoute){\r\n        this.routes.push(newRoute);\r\n\r\n        if (this.routeQueue.length === 0){\r\n            //start from last one\r\n            this.__zzOnRoute(this.routes.length - 1);\r\n        }\r\n        \r\n        return newRoute;\r\n    }\r\n\r\n    exactMatch(route, fn, self){\r\n        return this.__zzAddRoute(\r\n            new RouteExactMatch(this, this.toUrl(route), fn, self)\r\n        );\r\n    }\r\n\r\n    add(route, fn, self){\r\n        if (typeof route === 'function'){\r\n            return this.__zzAddRoute(\r\n                new RouteNoMatch(this, route, fn)\r\n            );\r\n        }\r\n        \r\n        return this.__zzAddRoute(\r\n            new RouteFromStart(this, this.toUrl(route), fn, self)\r\n        );\r\n    }\r\n\r\n    until(route, fn, self){\r\n        return this.__zzAddRoute(\r\n            new RouteUntilEnd(this, this.toUrl(route), fn, self)\r\n        );\r\n    }\r\n\r\n    noMatch(fn, self){\r\n        return this.__zzAddRoute(\r\n            new RouteNoMatch(this, fn, self)\r\n        );\r\n    }\r\n\r\n    onChange(fn, self){\r\n        return this.on('change', fn, self);\r\n    }\r\n\r\n    async __zzRun(route, index){\r\n        for (let i = index; i < this.routes.length; i++){\r\n            this.isExact |= await this.routes[i].runMatch(route);\r\n        }\r\n        \r\n        if (!this.isExact){\r\n            //no exact path, run wildcard ways\r\n            for (let i = index; i < this.routes.length; i++){\r\n                await this.routes[i].runWildCard();\r\n            }\r\n        }\r\n    }\r\n\r\n    async __zzOnRoute(index){\r\n        index || (index = 0);\r\n        \r\n        let url = this.toUrl( decodeURI( window.location.pathname ) );\r\n        let idx = this.routeQueue.indexOf(url);\r\n        if (idx === -1){\r\n            this.routeQueue.push( url );\r\n        \r\n            if (this.routeQueue.length === 1){\r\n                do{\r\n                    this.isExact = false;\r\n                    \r\n                    this.path = '/'+this.routeQueue[0];\r\n                    \r\n                    await this.__zzRun( this.routeQueue[0], index );\r\n\r\n                    this.emit('change', this.routeQueue[0]);\r\n                    //always remove after run\r\n                    this.routeQueue.shift();\r\n                }while(this.routeQueue.length > 0);\r\n            }\r\n        }\r\n    }\r\n\r\n    toUrl(route){\r\n        if (Array.isArray(route)){\r\n            route = route.map(function(route){\r\n                if (route instanceof Route){\r\n                    route = route.route;\r\n                }\r\n                \r\n                if (typeof route === 'string'){\r\n                    return route;\r\n                }\r\n\r\n                return '';\r\n            }).join('/');\r\n        }\r\n        \r\n        if (typeof route === 'string'){\r\n            return Route.trimPath( route );\r\n        }\r\n        \r\n        return '';\r\n    }\r\n\r\n    go(url){\r\n        this.state = {url: url};\r\n        window.history.pushState(this.state, '', '/'+this.toUrl(url));\r\n        this.__zzOnRoute();\r\n    }\r\n\r\n    setState(object){\r\n        for (let name in object){\r\n            this.state[name] = object[name];\r\n        }\r\n        \r\n        window.history.replaceState(this.state, '', window.location.href);\r\n    }\r\n\r\n    constructor(){\r\n        super({\r\n            path: null\r\n        });\r\n        \r\n        this.routes = [];\r\n        this.routeQueue = [];\r\n        this.isExact = false;\r\n        \r\n        window.addEventListener('popstate', (event) => {\r\n            this.state = event.state;\r\n            this.__zzOnRoute();\r\n        });\r\n        this.path = '/'+this.toUrl(window.location.pathname);\r\n        \r\n        this.state = {};\r\n        this.setState({url: window.location.pathname});\r\n    }\r\n};\r\n\r\nmodule.exports = {Router: new Router};\n\n//# sourceURL=webpack:///../libs/lizzi/Router/index.js?");

/***/ }),

/***/ "../libs/lizzi/index.js":
/*!******************************!*\
  !*** ../libs/lizzi/index.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\r\n * Docs https://github.com/myrpg-fun/lizzi\r\n */\r\n\r\nlet {Event} = __webpack_require__(/*! ./Event */ \"../libs/lizzi/Event.js\");\r\n\r\nclass zzReference{\r\n    onSet(fn, self){}    \r\n    off(fn, self){}\r\n}\r\n\r\nclass zzDataRef extends zzReference{\r\n    onSet(fn, self){\r\n        return this.model.on('set:'+this.name, fn, self);\r\n    }\r\n    \r\n    off(fn, self){\r\n        this.model.off('set:'+this.name, fn, self);\r\n    }\r\n\r\n    constructor(model, name){\r\n        super();\r\n        \r\n        this.model = model;\r\n        this.name = name;\r\n        this.events = [];\r\n        \r\n        Object.defineProperty(this, 'value', {\r\n            get: () => this.model[this.name],\r\n            set: (value) => this.model[this.name] = value\r\n        });\r\n    }\r\n}\r\n\r\nclass zzFunctionRef extends zzReference{\r\n    onSet(fn, self){\r\n        for (let ref of this.refs){\r\n            ref.onSet(this.bfn, self);\r\n        }\r\n    }\r\n    \r\n    off(fn, self){\r\n        for (let ref of this.refs){\r\n            ref.off(this.bfn, self);\r\n        }\r\n    }\r\n\r\n    constructor(fn, refs){\r\n        super();\r\n        \r\n        this.fn = fn.bind(this);\r\n        this.refs = refs;\r\n    }\r\n}\r\n\r\nfunction FuncRef(fn, refs){\r\n    return new zzFunctionRef(fn, refs);\r\n}\r\n\r\nclass Data extends Event{\r\n    __zzEmitAfterSet(name, value){\r\n        if (this.__zzAfterEmitValues === null){\r\n            setTimeout(() => {\r\n                this.emit('set-values', {\r\n                    values: this.__zzAfterEmitValues, target: this\r\n                });\r\n                \r\n                this.__zzAfterEmitValues = null;\r\n            }, 0);\r\n            \r\n            this.__zzAfterEmitValues = {};\r\n        }\r\n        \r\n        this.__zzAfterEmitValues[name] = value;\r\n    }\r\n    \r\n    __zzSet(name, value){\r\n        var last = this.__zzValues[name];\r\n        if (last !== value){\r\n            this.__zzValues[name] = value;\r\n            this.emit('set', {\r\n                name: name, value: value, last: last, target: this\r\n            });\r\n            this.emit('set:'+name, {\r\n                name: name, value: value, last: last, target: this\r\n            });\r\n//            this.__zzEmitAfterSet(name, value);\r\n        }\r\n    }\r\n    \r\n    ref(name){\r\n        return new zzDataRef(this, name);\r\n    }\r\n    \r\n    set(values){\r\n        if (values instanceof Data){\r\n            values = values.values();\r\n        }\r\n        \r\n        let last = {};\r\n        //set all values\r\n        for (let name in values){\r\n            if (!(name in this.__zzValues) && name !== '__zzValues'){\r\n                Object.defineProperty(this, name, {\r\n                    get: () => this.__zzValues[name],\r\n                    set: this.__zzSet.bind(this, name)\r\n                });\r\n            }\r\n\r\n            last[name] = this.__zzValues[name];\r\n            this.__zzValues[name] = values[name];\r\n        }\r\n        \r\n        //then emit\r\n        for (let name in values){\r\n            let value = this.__zzValues[name];\r\n            if (last[name] !== value){\r\n                this.emit('set', {\r\n                    name: name, value: value, last: last[name], target: this\r\n                });\r\n                this.emit('set:'+name, {\r\n                    name: name, value: value, last: last[name], target: this\r\n                });\r\n//                this.__zzEmitAfterSet(name, value);\r\n            }\r\n        }\r\n        \r\n        return this;\r\n    }\r\n    \r\n    values(){\r\n        return Object.assign({}, this.__zzValues);\r\n    }\r\n    \r\n    get(name){\r\n        return this.__zzValues[name];\r\n    }\r\n    \r\n    unset(name){\r\n        Object.defineProperty(this, name, {set:undefined, get:undefined});\r\n        \r\n        this.emit('remove-value', {\r\n            name: name, value: this.__zzValues[name], target: this\r\n        });\r\n        \r\n        delete this.__zzValues[name];\r\n    }\r\n    \r\n    constructor(data){\r\n        super();\r\n        \r\n        !data && (data = {});\r\n        \r\n        this.__zzValues = {};\r\n        this.__zzAfterEmitValues = null;\r\n        \r\n        this.set(data);\r\n    }\r\n}\r\n\r\nclass Collection extends Event{\r\n    add(data, idx){\r\n        idx === undefined && (idx = this.__zzArray.length);\r\n        !Array.isArray(data) && (data = [data]);\r\n        \r\n        return this.splice(idx, 0, ...data);\r\n    }\r\n    \r\n    addBefore(element, data){\r\n        let idx = this.indexOf(element);\r\n        if (idx === -1){\r\n            return this;\r\n        }\r\n        \r\n        return this.add(data, idx);\r\n    }\r\n    \r\n    addAfter(element, data){\r\n        let idx = this.indexOf(element);\r\n        if (idx === -1){\r\n            return this;\r\n        }\r\n        \r\n        return this.add(data, idx+1);\r\n    }\r\n    \r\n    removeAll(){\r\n        let all = this.__zzArray;\r\n        \r\n        this.__zzArray = [];\r\n        \r\n        all.forEach(function(val, idx){\r\n            this.emit('remove', val, 0, this);\r\n        }, this);\r\n        \r\n        this.emit('remove-values', all, this);\r\n        this.emit('change-values', all, this);\r\n        \r\n        return this;\r\n    }\r\n    \r\n    splice(index, count){\r\n        let newData = [].slice.call(arguments, 2);\r\n        let removeData = this.__zzArray.splice(index, count, ...newData);\r\n        \r\n        if (count > 0){\r\n            for (let i in removeData){\r\n                this.emit('remove', removeData[i], Number(index)+Number(i), this);\r\n            }\r\n        \r\n            this.emit('remove-values', removeData, this);\r\n        }\r\n\r\n        if (newData.length > 0){\r\n            newData.forEach((val, i) => {\r\n                this.emit('add', val, i+index, this);\r\n            });\r\n\r\n            this.emit('add-values', newData, index, this);\r\n        }\r\n        \r\n        this.emit('change-values', this.__zzArray, this);\r\n    }\r\n    \r\n    remove(data){\r\n        !Array.isArray(data) && (data = [data]);\r\n        \r\n        data.forEach(function(val){\r\n            let i = this.indexOf(val);\r\n            if (i !== -1){\r\n                this.splice(i, 1);\r\n            }\r\n        }.bind(this));\r\n        \r\n        this.emit('remove-values', data, this);\r\n        this.emit('change-values', this.__zzArray, this);\r\n        \r\n        return this;\r\n    }\r\n    \r\n    getByIndex(index){\r\n        return this.__zzArray[index];\r\n    }\r\n    \r\n    findIndex(func){\r\n        return this.__zzArray.findIndex(func);\r\n    }\r\n    \r\n    find(func){\r\n        return this.__zzArray.find(func);\r\n    }\r\n    \r\n    filter(func){\r\n        return this.__zzArray.filter(func);\r\n    }\r\n    \r\n    indexOf(val){\r\n        return this.__zzArray.indexOf(val);\r\n    }\r\n    \r\n    has(val){\r\n        return this.__zzArray.indexOf(val) !== -1;\r\n    }\r\n    \r\n    replace(data){\r\n        !Array.isArray(data) && (data = [data]);\r\n        \r\n        let last = this.__zzArray;\r\n        this.__zzArray = data;\r\n        \r\n        this.emit('replace-values', data, last, this);\r\n        this.emit('change-values', data, this);\r\n        \r\n        return this;\r\n    }\r\n    \r\n    refresh(){\r\n        this.emit('change-values', this.__zzArray, this);\r\n    }\r\n    \r\n    async forEach(fn, self){\r\n        for (let i in this.__zzArray){\r\n            let result = fn.call(self, this.__zzArray[i], i, this.__zzArray);\r\n            if (result instanceof Promise){\r\n                await result;\r\n            }\r\n        }\r\n    }\r\n    \r\n    *[Symbol.iterator]() {\r\n        for (let el of this.__zzArray){\r\n            yield el;\r\n        }\r\n    }\r\n\r\n    toArray(){\r\n        return this.__zzArray;\r\n    }\r\n    \r\n    constructor(array){\r\n        super();\r\n        \r\n        this.__zzArray = [];\r\n  \r\n        Object.defineProperty(this, 'length', {\r\n            get: () => this.__zzArray.length\r\n        });\r\n        \r\n        Object.defineProperty(this, 'elements', {\r\n            get: () => this.__zzArray.slice()\r\n        });\r\n        \r\n        if (array){\r\n            this.add(array);\r\n        }\r\n    }\r\n}\r\n\r\nclass LazyCollection extends Event{\r\n    /*\r\n     * filter/sort class\r\n     * \r\n     * @param {Array} elements - array of original elements\r\n     * @returns {Array} - filtered / sorted array for new collection\r\n     */\r\n    filter(elements){\r\n        return elements;\r\n    }\r\n    \r\n    setFilter(fn){\r\n        if (typeof fn === 'function'){\r\n            this.__zzFilterFn = fn;\r\n            this.refresh();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    refresh(){\r\n        this.__zzNeedUpdate = true;\r\n        this.emit('replace-values', this, this.__zzArray.slice(), this);\r\n        this.emit('change-values', this, this);\r\n    }\r\n    \r\n    /*\r\n     * add to filter outer collection to set filtered array\r\n     * \r\n     * @param {zzFCollection} collection - outer collection\r\n     */\r\n    to(collection){\r\n        this.on('change-values', () => collection.replace(this.elements), collection);\r\n        \r\n        collection.replace(this.elements);\r\n        \r\n        return this;\r\n    }\r\n    \r\n    toArray(){\r\n        if (this.__zzNeedUpdate){\r\n            this.__zzArray = this.__zzFilterFn(this.collection.elements);\r\n            this.__zzNeedUpdate = false;\r\n        };\r\n        \r\n        return this.__zzArray;\r\n    }\r\n    \r\n    async forEach(fn, self){\r\n        for (let i in this.toArray()){\r\n            let result = fn.call(self, this.__zzArray[i], i, this.__zzArray);\r\n            if (result instanceof Promise){\r\n                await result;\r\n            }\r\n        }\r\n    }\r\n    \r\n    *[Symbol.iterator]() {\r\n        for (let el of this.toArray()){\r\n            yield el;\r\n        }\r\n    }\r\n    \r\n    constructor(collection){\r\n        super();\r\n        \r\n        this.collection = collection;\r\n        this.collection.on('change-values', this.refresh, this);\r\n        \r\n        this.__zzFilterFn = this.filter;\r\n        this.__zzArray = [];\r\n        this.__zzNeedUpdate = true;\r\n        \r\n        Object.defineProperty(this, 'length', {\r\n            get: () => this.toArray().length\r\n        });\r\n        \r\n        Object.defineProperty(this, 'elements', {\r\n            get: () => this.toArray().slice()\r\n        });\r\n    }\r\n}\r\n\r\nmodule.exports = {zzReference, Data, Collection, LazyCollection, FuncRef};\n\n//# sourceURL=webpack:///../libs/lizzi/index.js?");

/***/ }),

/***/ "./app.js":
/*!****************!*\
  !*** ./app.js ***!
  \****************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _reboot_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/reboot.css */ \"./reboot.css\");\n/* harmony import */ var _reboot_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_reboot_css__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lizzi_DOM_MainApp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lizzi/DOM/MainApp */ \"../libs/lizzi/DOM/MainApp.js\");\n/* harmony import */ var lizzi_DOM_MainApp__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lizzi_DOM_MainApp__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lizzi_Router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lizzi/Router */ \"../libs/lizzi/Router/index.js\");\n/* harmony import */ var lizzi_Router__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lizzi_Router__WEBPACK_IMPORTED_MODULE_2__);\n\r\n\r\n\r\n\r\nclass MyApp extends lizzi_DOM_MainApp__WEBPACK_IMPORTED_MODULE_1__[\"MainApp\"]{\r\n    constructor(){\r\n        super({\r\n            title: 'Topia.io - loading'\r\n        });\r\n        \r\n        lizzi_Router__WEBPACK_IMPORTED_MODULE_2__[\"Router\"].exactMatch([], () => \r\n            Promise.all(/*! import() */[__webpack_require__.e(0), __webpack_require__.e(1)]).then(__webpack_require__.bind(null, /*! ./topia/app */ \"./topia/app.js\")).then(\r\n                app => {\r\n                    this.title = 'Topia.io';\r\n                    this.app = app.default.createView();\r\n                }\r\n            )\r\n        );\r\n\r\n        //404 error\r\n        lizzi_Router__WEBPACK_IMPORTED_MODULE_2__[\"Router\"].noMatch(() => \r\n            __webpack_require__.e(/*! import() */ 2).then(__webpack_require__.bind(null, /*! ./404/index */ \"./404/index.js\")).then(\r\n                app => {\r\n                    this.title = 'Topia.io - Page not found';\r\n                    this.app = app.default.createView();\r\n                }\r\n            )\r\n        );\r\n    }\r\n};\r\n\r\nconst app = new MyApp;\r\n\n\n//# sourceURL=webpack:///./app.js?");

/***/ }),

/***/ "./reboot.css":
/*!********************!*\
  !*** ./reboot.css ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n    if(false) { var cssReload; }\n  \n\n//# sourceURL=webpack:///./reboot.css?");

/***/ })

/******/ });